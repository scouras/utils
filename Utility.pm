package Utility;

#use 5.008006;
use strict;
use warnings;
use Carp;
#use Carp::Always;
use Data::Dumper;
use Math::Trig;
use Math::Round;
use Cwd;
use File::Spec;
use IPC::Open3;
use File::Which;
use English '-no_match_vars';
use POSIX
require Exporter;
use Math::Trig;

our @ISA = qw(Exporter);

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration	use RotLib ':all';
# If you do not need this, moving things directly into @EXPORT or @EXPORT_OK
# will save memory.
our %EXPORT_TAGS = ( 'all' => [ qw(

  $ANGSTROM
  $ALPHA
  $BETA

  @AA
  %AA_3to1
  @ALL_ANGLE_NAMES
	%AA 
  @MC_ATOMS
  @SC_ATOMS
  %CHARGED_ATOMS
  %ATOM_NAME_TRANSLATION_OPTIONS
  %ATOM_NAME_TRANSLATION_LOOKUP
  %ATOM_ORDER
  %AA_SHORT
 
  @RESIDUE_TYPES
  %RESIDUE_TYPES 
  %KNOWN_RESIDUES
  %KNOWN_ATOMS
  &Assign_Residue_Types
  &Get_Atom_Group_Elements
  &Is_Hydrogen_Atom
  
  &Sum
  &Min 
  &Max 
  &Mean_and_Stddev
  &Covariance
  &Correlation
  &Hist_Mean_and_Stddev
  &Histogram
  &Make_Histogram
  &Make_LogX_Histogram
  &Histogram_Shift_Min_to_X
  &Normalize_Histogram
  &Normalize_Histogram_to_Population
  &Normalize_Histogram_2D
  &Zero_Blanks_In_Histogram
  &Combine_Histograms
  &Combine_Histograms_2D
  &Combine_Histograms_2D_Fast
  &Copy_Histogram
  &Copy_Histogram_2D
  &Sum_Histogram
  &Sum_Histogram_2D
  &Rebin_Histogram
  &Find_Modes
  &Calculate_Distribution_Statistics
  &Displacement
  &Displacement_Raw

  &Get_RE_Matches
  &Distance
  
  &Parse_Range
  &Adjust_Residues
  &Range 
  &Clean_Line 
  &Clean_Filename
  &Make_Directories
  &Split_Path
  &Trim 
  &Process_Range
  &In_Range
  &Past_Range
  &Get_Indecies
  &Interval_Samples

  &Unique 
  &Unique_Counts
  &Make_Contiguous_Lists
  &Union
  &Intersection
  &Difference
  &Get_Log_Range
  &Is_Number
  &Commafy_Integer
  &Is_Integer
  &Is_Positive_Integer
  &Is_Negative_Integer
  &Get_Number
  &Transpose

  &Vector_From_Points
  &Vector_Cross
  &Vector_Minus
  &Vector_Scale
  &Vector_Dot
  &Vector_Mag
  &Vector_Angle
  &Dihedral_Angle

  &Human_Readable_Size
  &Human_Readable_Condensed_Date
  &Human_Readable_Time
  &Rate_Initialize
  &Rate_Increment
  &Rate_Print
  &Rate_Update
  &Measure_Rate
  &Print_Double_Rate_Header
  &Print_Double_Rate_Line

  &Matrix_to_Text
  &Text_to_Matrix
  &Read_Matrix
  &Write_Matrix
  &Flatten
  &Open_File
  &Write_File
  &Write_PDB_Simple
  &Read_PDB_Simple
  &Write_CRD_Simple
  &Read_CRD_Simple

  &Parse_Sequence_File
  &Seq_Map
  &Seq_Translate_Residue
  &Seq_Translate_Index

  &Try_Command
  &Set_Flags
  &Get_Exe
  &Report_Error

) ] );

our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

our @EXPORT = qw();


# CVS VERSION INFORMATION (AUTOMAGICALLY GENERATED BY CVS)
'$Revision: 1.8 $'              =~ /^.Revision: (.*) \$/; our $VERSION    = $1;
'$Date: 2009/08/24 22:41:12 $'  =~ /^.Date: (.*) \$/;     our $CHECKED_IN = $1;
'$Author: scouras $'            =~ /^.Author: (.*) \$/;   our $AUTHOR     = $1;



##### Unicode Characters

our $Angstrom = "\\u00C5";
our $alpha    = "\\u03B1";
our $beta     = "\\u03B2";



##############################################################################
#                                                                    VARIABLES
##############################################################################

our $START_TIME = time;

our @ALL_ANGLE_NAMES = (
  "omega", 
  "phi", 
  "psi", 
  "chi1", 
  "chi2", 
  "chi21", 
  "chi22", 
  "chi3", 
  "chi31", 
  "chi32", 
  "chi4", 
  "chi5", 
  "chi6", 
  "chi61", 
  "chi62",
  "cis",
  "theta",
);


our %AA = (
  ala => { 
    ab        => 'A',
    name      => 'alanine',
    sc        => [],
    o         => [],
    h         => ['chi1'],
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 HB3)],
    x0_atoms  => [qw(CB HB1 HB2 HB3)],
    chi_sel   => [],
  },
  arg => { 
    ab        => 'R',
    name      => 'arganine',
    sc        => ['chi1','chi2','chi3','chi4'],  
    o         => [],
    h         => ['chi5', 'chi61', 'chi62'] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG HG1 HG2 CD HD1 HD2 NE HE CZ NH1 HH11 HH12 NH2 HH21 HH22)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG HG1 HG2)],
    x2_atoms  => [qw(CD HD1 HD2)],
    x3_atoms  => [qw(NE HE)],
    x4_atoms  => [qw(CZ NH1 HH11 HH12 NH2 HH21 HH22)],
    chi_sel   =>[[qw(CB HB*)],[qw(CG HG*)],[qw(CD HD*)],[qw(NE HE CZ NH* HH*)]],
  },
  asn => { 
    ab        => 'N',
    name      => 'asparagine',
    sc        => ['chi1','chi2'],
    o         => [],
    h         => ['cis'] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG OD1 ND2 HD21 HD22)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(OD1 ND2 HD21 HD22)],
    chi_sel   => [[qw(CB HB*)],[qw(CG OD1 ND2 HD*)]],
  },
  asp => { 
    ab        => 'D',
    name      => 'aspartate',
    sc        => ['chi1','chi2'],    
    o         => [],
    h         => [],
    sym       => {'chi2'=>2},
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG OD1 OD2)],
    sc_atoms  => [qw(CB HB1 HB2 CG OD1 OD2 HO)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(OD1 OD2 HO)],
    chi_sel   => [[qw(CB HB*)],[qw(CG OD*)]],
  },
  ash         => { 
    ab        => 'd',
    name      => 'aspartate',
    sc        => ['chi1','chi2'],
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG OD1 OD2 HO)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(OD1 OD2 HO)],
  },
  cyh         => {
    ab        => 'c',
    name      => 'cysteine',
    sc        => ['chi1'],     
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 SG HS)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(SG HS)],
  },
  cys => {
    ab        => 'C',
    name      => 'cysteine',
    sc        => ['chi1'],    
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 SG)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(SG)],
  },
  gln => { 
    ab        => 'Q',
    name      => 'glutamine',
    sc        => ['chi1','chi2','chi3'],   
    o         => [],
    h         => ['cis'] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG HG1 HG2 CD OE1 NE2 HE21 HE22)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG HG1 HG2)],
    x2_atoms  => [qw(CD)],
    x3_atoms  => [qw(OE1 NE2 HE21 HE22)],
  },
  glu => { 
    ab        => 'E',
    name      => 'glutamate',
    sc        => ['chi1','chi2','chi3'],   
    o         => [],
    h         => [],
    sym       => {'chi3' => 2},
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG HG1 HG2 CD OE1 OE2)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG HG1 HG2)],
    x2_atoms  => [qw(CD)],
    x3_atoms  => [qw(OE1 OE2)],
  },
  glh => {
    ab        => 'e',
    name      => 'glutamate',
    sc        => ['chi1','chi2','chi3'],    
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG HG1 HG2 CD OE1 OE2 HO)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG HG1 HG2)],
    x2_atoms  => [qw(CD)],
    x3_atoms  => [qw(OE1 OE2 HO)],
  },
  gly => { 
    ab        => 'G',
    name      => 'glycine',
    sc        => [],   
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA1 HA2 C O)],
    sc_atoms  => [qw()],
  },
  hin => { 
    ab        => 'H',
    name      => 'histidine',
    sc        => ['chi1','chi2'],  
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG ND1 CE1 HE1 NE2 CD2 HD2)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(ND1 CE1 HE1 NE2 CD2 HD2)],
  },
  his => { 
    ab        => 'H',
    name      => 'histidine',
    sc        => ['chi1','chi2'],  
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG ND1 HD1 CE1 HE1 NE2 CD2 HD2)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(ND1 HD1 CE1 HE1 NE2 CD2 HD2)],
  },
  hie => { 
    ab        => 'H',
    name      => 'histidine',
    sc        => ['chi1','chi2'],   
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG ND1 CE1 HE1 NE2 HE2 CD2 HD2)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(ND1 CE1 HE1 NE2 HE2 CD2 HD2)],
  },
  hid => {
    ab        => 'H',
    name      => 'histidine',
    sc        => ['chi1','chi2'],  
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG ND1 HD1 CE1 HE1 NE2 CD2 HD2)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(ND1 HD1 CE1 HE1 NE2 CD2 HD2)],
  },
  hip => { 
    ab        => 'h',
    name      => 'histidine',
    sc        => ['chi1','chi2'], 
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG ND1 HD1 CE1 HE1 NE2 HE2 CD2 HD2)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(ND1 HD1 CE1 HE1 NE2 HE2 CD2 HD2)],
  },
  ile => {
    ab        => 'I',
    name      => 'isoleucine',
    sc        => ['chi1','chi2'],            
    #sc        => ['chi1','chi21'],            
    o         => [],
    h         => ['chi22', 'chi31'] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB CG1 HG11 HG12 CG2 HG21 HG22 HG23 CD1 HD11 HD12 HD13)],
    x0_atoms  => [qw(CB HB)],
    x1_atoms  => [qw(CG1 HG11 HG12 CG2 HG21 HG22 HG23)],
    x2_atoms  => [qw(CD1 HD11 HD12 HD13)],
  },
  leu => { 
    ab        => 'L',
    name      => 'leucine',
    sc        => ['chi1','chi2'],          
    o         => [],
    h         => ['chi31', 'chi32'] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG HG CD1 HG11 HG12 HG13 CD2 HD21 HD22 HD23)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG HG)],
    x2_atoms  => [qw(CD1 HG11 HG12 HG13 CD2 HD21 HD22 HD23)],
  },
  lys => {
    ab        => 'K',
    name      => 'lysine',
    sc        => ['chi1','chi2','chi3','chi4'],
    o         => [],
    h         => ['chi5'] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG HG1 HG2 CD HD1 HD2 CE HE1 HE2 NZ HZ1 HZ2 HZ3)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG HG1 HG2)],
    x2_atoms  => [qw(CD HD1 HD2)],
    x3_atoms  => [qw(CE HE1 HE2)],
    x4_atoms  => [qw(NZ HZ1 HZ2 HZ3)],
  },
  met => {
    ab        => 'M',
    name      => 'methionine',
    sc        => ['chi1','chi2','chi3'],      
    o         => [],
    h         => ['chi4'] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG HG1 HG2 SD CE HE1 HE2 HE3)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG HG1 HG2)],
    x2_atoms  => [qw(SD)],
    x3_atoms  => [qw(CE HE1 HE2 HE3)],
  },
  phe => {
    ab        => 'F',
    name      => 'phenylalanine',
    sc        => ['chi1','chi2'],             
    o         => [],
    h         => [],
    sym       => {'chi2'=>2},
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG CD1 HD1 CE1 HE1 CZ HZ CE2 HE2 CD2 HD2)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(CD1 HD1 CE1 HE1 CZ HZ CE2 HE2 CD2 HD2)],
  },
  pro     => { 
    ab    => 'P',
    name  => 'proline',
    sc    => ['chi1'],                     
    o     => ['chi2', 'chi3', 'chi4', 'theta'],
    h     => [] ,
    mc_atoms => [qw(N CA HA1 C O)],
    sc_atoms => [qw(CB HB1 HB2 CG HG1 HG2 CD HD1 HD2)],
    x0_atoms => [qw(CB HB1 HB2 CD HD1 HD2)],
    x1_atoms => [qw(CG HG1 HG2)],
  },
  ser => { 
    ab        => 'S',
    name      => 'serine',
    sc        => ['chi1'],                    
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 OG HG)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(OG HG)],
  },
  thr => {
    ab        => 'T',
    name      => 'threonine',
    sc        => ['chi1'],                   
    o         => [],
    h         => ['chi22'] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB OG1 HG1 CG2 HG21 HG22 HG23)],
    x0_atoms  => [qw(CB HB)],
    x1_atoms  => [qw(OG1 HG1 CG2 HG21 HG22 HG23)],
  },
  trp => {
    ab        => 'W',
    name      => 'tryptophan',
    sc        => ['chi1','chi2'],            
    o         => [],
    h         => [] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG CD1 HD1 NE1 HE1 CE2 CZ2 HZ2 CH2 HH2 CZ3 HZ3 CE3 HE3 CD2)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(CD1 HD1 NE1 HE1 CE2 CZ2 HZ2 CH2 HH2 CZ3 HZ3 CE3 HE3 CD2)],
  },
  tyr => { 
    ab        => 'Y',
    name      => 'tyrosine',
    sc        => ['chi1','chi2'],            
    o         => [],
    h         => ['chi6'],
    sym       => {'chi2'=>2},
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB1 HB2 CG CD1 HD1 CE1 HE1 CZ OH HH CE2 HE2 CD2 HD2)],
    x0_atoms  => [qw(CB HB1 HB2)],
    x1_atoms  => [qw(CG)],
    x2_atoms  => [qw(CD1 HD1 CE1 HE1 CZ OH HH CE2 HE2 CD2 HD2)],
  },
  val => {
    ab        => 'V',
    name      => 'valine',
    sc        => ['chi1'],                   
    o         => [],
    h         => ['chi21', 'chi22'] ,
    mc_atoms  => [qw(N H CA HA C O)],
    sc_atoms  => [qw(CB HB CG1 HG11 HG12 HG13 CG2 HG21 HG22 HG23)],
    x0_atoms  => [qw(CB HB)],
    x1_atoms  => [qw(CG1 HG11 HG12 HG13 CG2 HG21 HG22 HG23)],
  },

);





##############################################################################
#                            DIHEDRAL ANGLE DEFINITIONS
#-----------------------------------------------------------------------------
# Use XXX as the default dihedral angle definition for all residues.
# At the end, explicitly delete the chi1 angles for ALA and GLY.
# + or - after an atom name indicate the atom from the previous or subsequent
# residue.
##############################################################################

our %DIHEDRAL_ANGLES = (
  PHI   => { XXX => [ qw(  C-  N  CA   C  ) ], },
  PSI   => { XXX => [ qw(  N  CA   C   N+ ) ], },
  OMEGA => { XXX => [ qw( CA-  C-  N  CA  ) ], },
  CHI1  => { XXX => [ qw(  N  CA  CB  CG  ) ],
             CYH => [ qw(  N  CA  CB  SG  ) ],
             CYS => [ qw(  N  CA  CB  SG  ) ],
             ILE => [ qw(  N  CA  CB  CG1 ) ],
             SER => [ qw(  N  CA  CB  OG  ) ],
             THR => [ qw(  N  CA  CB  OG1 ) ],
             VAL => [ qw(  N  CA  CB  CG1 ) ], },
  CHI2  => { ARG => [ qw( CA  CB  CG  CD  ) ], 
             GLH => [ qw( CA  CB  CG  CD  ) ], 
             GLN => [ qw( CA  CB  CG  CD  ) ], 
             GLU => [ qw( CA  CB  CG  CD  ) ], 
             LYS => [ qw( CA  CB  CG  CD  ) ], 
             ILE => [ qw( CA  CB  CG1 CD1 ) ], 
             LEU => [ qw( CA  CB  CG  CD1 ) ],
             PHE => [ qw( CA  CB  CG  CD1 ) ],
             TRP => [ qw( CA  CB  CG  CD1 ) ],
             TYR => [ qw( CA  CB  CG  CD1 ) ],
             HIP => [ qw( CA  CB  CG  ND1 ) ],
             HIS => [ qw( CA  CB  CG  ND1 ) ],
             HIE => [ qw( CA  CB  CG  ND1 ) ],
             HID => [ qw( CA  CB  CG  ND1 ) ],
             ASH => [ qw( CA  CB  CG  OD1 ) ],
             ASN => [ qw( CA  CB  CG  OD1 ) ],
             ASP => [ qw( CA  CB  CG  OD1 ) ],
             MET => [ qw( CA  CB  CG  SD  ) ], },
  CHI3  => { LYS => [ qw( CB  CG  CD  CE  ) ],
             ARG => [ qw( CB  CG  CD  NE  ) ],
             GLH => [ qw( CB  CG  CD  OE1 ) ],
             GLN => [ qw( CB  CG  CD  OE1 ) ],
             GLU => [ qw( CB  CG  CD  OE1 ) ],
             MET => [ qw( CB  CG  SD  CE  ) ], },
  CHI4  => { LYS => [ qw( CG  CD  CE  NZ  ) ],
             ARG => [ qw( CG  CD  NE  CZ  ) ], },
);

foreach my $angle ( keys %DIHEDRAL_ANGLES ) { 
  foreach my $resn ( map { uc } (keys %AA) ) { 
    if ( not defined $DIHEDRAL_ANGLES{$angle}{$resn} ) { 
      if ( defined $DIHEDRAL_ANGLES{$angle}{XXX} ) { 
        $DIHEDRAL_ANGLES{$angle}{$resn} = $DIHEDRAL_ANGLES{$angle}{XXX};
        #print "Adding dihedral angle for $resn $angle\n";
      }
    }
  }
}
delete $DIHEDRAL_ANGLES{CHI1}{ALA};
delete $DIHEDRAL_ANGLES{CHI1}{GLY};

#for my $key (keys %DIHEDRAL_ANGLES) { 
#  $DIHEDRAL_ANGLES{lc $key} = $DIHEDRAL_ANGLES{uc $key};
#}

#print Dumper(\%DIHEDRAL_ANGLES);
#exit;        
  









##############################################################################
#                                   ADDITIONAL AMINO ACID PROPERTIES
##############################################################################

############################################################# VOLUME
# Volume is taken from this source and is not validated for any
# particular purpose as of yet.
#   http://prowl.rockefeller.edu/aainfo/volume.htm
#   A.A. Zamyatin, Protein Volume in Solution, 
#     Prog. Biophys. Mol. Biol. 24(1972)107-123.
# Happens to be identical to:
#   http://www.imb-jena.de/IMAGE_AA.html
#   C.Chothia, J. Mol. Biol., 105(1975)1-14
$AA{'ala'}{'volume'} =  88.6;
$AA{'arg'}{'volume'} = 173.4;
$AA{'asp'}{'volume'} = 111.1;
$AA{'asn'}{'volume'} = 114.1;
$AA{'cys'}{'volume'} = 108.5;
$AA{'glu'}{'volume'} = 138.4;
$AA{'gln'}{'volume'} = 143.8;
$AA{'gly'}{'volume'} =  60.1;
$AA{'his'}{'volume'} = 153.2;
$AA{'ile'}{'volume'} = 166.7;
$AA{'leu'}{'volume'} = 166.7;
$AA{'lys'}{'volume'} = 168.6;
$AA{'met'}{'volume'} = 162.9;
$AA{'phe'}{'volume'} = 189.9;
$AA{'pro'}{'volume'} = 112.7;
$AA{'ser'}{'volume'} =  89.0;
$AA{'thr'}{'volume'} = 116.1;
$AA{'trp'}{'volume'} = 227.8;
$AA{'tyr'}{'volume'} = 193.6;
$AA{'val'}{'volume'} = 140.0;

############################################################### MASS
#   http://www.imb-jena.de/IMAGE_AA.html
#   C.Chothia, J. Mol. Biol., 105(1975)1-14
$AA{'ala'}{'mass'} =  71.09;
$AA{'arg'}{'mass'} = 156.19;
$AA{'asp'}{'mass'} = 115.09;
$AA{'asn'}{'mass'} = 114.11;
$AA{'cys'}{'mass'} = 103.15;
$AA{'glu'}{'mass'} = 129.12;
$AA{'gln'}{'mass'} = 128.14;
$AA{'gly'}{'mass'} =  57.05;
$AA{'his'}{'mass'} = 137.14;
$AA{'ile'}{'mass'} = 113.16;
$AA{'leu'}{'mass'} = 113.16;
$AA{'lys'}{'mass'} = 128.17;
$AA{'met'}{'mass'} = 131.19;
$AA{'phe'}{'mass'} = 147.18;
$AA{'pro'}{'mass'} =  97.12;
$AA{'ser'}{'mass'} =  87.08;
$AA{'thr'}{'mass'} = 101.11;
$AA{'trp'}{'mass'} = 186.12;
$AA{'tyr'}{'mass'} = 163.18;
$AA{'val'}{'mass'} =  99.14;




####################################################### SURFACE AREA
#     This is derived from the standard.data file from NACCESS 2.1.1
#     It is left in this somewhat raw format so I can just paste in 
#     a new copy should one come up.
#RES  All-atoms  Non-P-side  Polar-Side  Total-Side  Main-Chain  Non-Polar All-polar
my $NACCESS_SURFACE_AREA = <<NACCESS
ALA  107.95    69.41     0.00    69.41    38.54    71.38    36.58
CYS  134.28    96.75     0.00    96.75    37.53    97.93    36.35
ASP  140.39    48.00    54.69   102.69    37.70    49.24    91.15
GLU  172.25    59.10    75.64   134.74    37.51    60.29   111.96
PHE  199.48   164.11     0.00   164.11    35.37   165.25    34.23
GLY   80.10    32.33     0.00    32.33    47.77    37.55    42.55
HIS  182.88    96.01    51.07   147.08    35.80    97.15    85.73
ILE  175.12   137.96     0.00   137.96    37.16   139.14    35.98
LYS  200.81   115.38    47.92   163.30    37.51   116.57    84.24
LEU  178.63   141.12     0.00   141.12    37.51   142.31    36.32
MET  194.15   156.64     0.00   156.64    37.51   157.84    36.32
ASN  143.94    44.98    61.26   106.24    37.70    46.23    97.72
PRO  136.13   119.90     0.00   119.90    16.23   120.95    15.19
GLN  178.50    51.03    89.96   140.99    37.51    52.22   126.28
ARG  238.76    76.60   124.65   201.25    37.51    77.80   160.97
SER  116.50    46.89    31.22    78.11    38.40    48.55    67.95
THR  139.27    74.54    27.17   101.70    37.57    75.72    63.55
VAL  151.44   114.28     0.00   114.28    37.16   115.47    35.97
TRP  249.36   187.67    23.60   211.26    38.10   189.67    59.69
TYR  212.76   135.35    42.03   177.38    35.38   136.50    76.26
NACCESS
;

my @NACCESS_SURFACE_AREA 
  = map { [ split /\s+/, $_ ] } 
    split "\n", $NACCESS_SURFACE_AREA;
foreach my $line ( @NACCESS_SURFACE_AREA ) { 
  my $res = lc $line->[0];
  $AA{$res}{'area'} = {
    total       => $line->[1],
    side_non    => $line->[2],
    side_polar  => $line->[3],
    side        => $line->[4],
    main        => $line->[5],
    non         => $line->[6],
    polar       => $line->[7],
  };
  #print "AREA: $res\t$line->[1]\n";
}



############################ ADDITIONAL ATOM AND CHI ANGLE GROUPINGS
our @AA = sort keys %AA;
our %AA_3to1 = map { $AA{$_}{'ab'} => $_, $_ => $AA{$_}{'ab'} } keys %AA;
our @MC_ATOMS      = Unique ( 'OT', map { @{$_->{'mc_atoms'}} } values %AA);
our @SC_ATOMS      = Unique (       map { @{$_->{'sc_atoms'}} } values %AA);
our %CHARGED_ATOMS = ( LYS => ['NZ'],
                       ARG => ['NH1', 'NH2', 'NE'],
                       HIP => ['ND1', 'NE2'],
                       GLU => ['OE1', 'OE2'],
                       ASP => ['OD1', 'OD2'],
                     );
for my $res ( keys %CHARGED_ATOMS ) { 
  $CHARGED_ATOMS{"$res\_N"} = [@{$CHARGED_ATOMS{$res}}];
  $CHARGED_ATOMS{"$res\_C"} = [@{$CHARGED_ATOMS{$res}}];
}
for my $res ( keys %AA ) {
  $res = uc $res;
  push @{$CHARGED_ATOMS{"$res\_N"}}, 'N';
  push @{$CHARGED_ATOMS{"$res\_C"}}, 'O', 'OT';
}


# For simplicity, allow upper case access too.
foreach my $aa ( keys %AA ) {
  $AA{uc $aa} = $AA{$aa};
}

# Add universal main chain dihedrals
foreach my $aa ( sort keys %AA ) {
  $AA{$aa}{mc_ang     } = [qw(omega phi psi)];
  $AA{$aa}{aa_ang     } = [map { @{$AA{$aa}{$_} || []}} qw(mc_ang sc_ang o_ang h_ang) ];
  #$AA{$aa}{sd_atoms   } = [map { @{$AA{$aa}{"x$_\_atoms"} || [] }} 0..4 ];
  $AA{$aa}{aa_atoms   } = [@{$AA{$aa}{mc_atoms}}, @{$AA{$aa}{sc_atoms}}];
};



#################################################################### 
#                                             RESIDUE AND ATOM TYPES
#################################################################### 

our @RESIDUE_TYPES = qw(PROTEIN WATER SOLVENT ANION CATION ION METAL LIGAND HOLE);
our %RESIDUE_TYPES = (
  PROTEIN   => 'P',
  WATER     => 'W',
  #SOLVENT   => 'S',
  ANION     => 'A',
  CATION    => 'C',
  METAL     => 'M',
  LIGAND    => 'L',
  UNKOWN    => 'U',
  HOLE      => 'H',
);
# Map upper and lower case lookups
map { $RESIDUE_TYPES{lc $_} = uc $RESIDUE_TYPES{$_} } keys %RESIDUE_TYPES;
map { $RESIDUE_TYPES{lc $RESIDUE_TYPES{$_}} = uc $_ } keys %RESIDUE_TYPES;
map { $RESIDUE_TYPES{uc $RESIDUE_TYPES{$_}} = uc $_ } keys %RESIDUE_TYPES;


#==================================================== Known Residues

our %RESIDUE_TYPE_MAP = (
  PROTEIN => [keys %AA],
  WATER   => [qw(HOH WAT DOD)],
  #SOLVENT => [qw(IPA MPD)],
  ANION   => [qw(Cl F Br PO4 SO4)],
  CATION  => [qw(NH4)],
  METAL   => [qw(Li Na K Ca Fe Cu Zn Fe2 Fe)],
  LIGAND  => [qw(EPE BTB POP POPC IPA ACT EDO)],
  HOLE    => [qw(CAV)],
);

our %KNOWN_RESIDUES = %AA;
foreach my $type ( @RESIDUE_TYPES ) { 
  foreach my $res ( @{$RESIDUE_TYPE_MAP{$type}} ) { 
    $KNOWN_RESIDUES{   $res}{type} = $type;
    $KNOWN_RESIDUES{uc $res}{type} = $type;
    $KNOWN_RESIDUES{lc $res}{type} = $type;
  }
}


#============================================== Assign Residue Types
# Quick subroutine that will assign residue types to a sequence.
# Operates in place on the types array.

sub Assign_Residue_Types { 
  my $resn = $_[0];
  my $type = $_[1];
  foreach my $i ( 0..$#$resn ) { 
    next if defined $type->[$i]; # skip pre defined residues
    my $r = $resn->[$i] or next; # skip missing residues
    if ( not defined $KNOWN_RESIDUES{$r} ) { 
      confess "Unrecognized residue: $i $r\n";# . Dumper(%KNOWN_RESIDUES);
    }
#    die "WTF? i: $i  r: $r\n"
#        . Dumper($KNOWN_RESIDUES{$r}) . "\n"
#        . Dumper($resn) . "\n"
#        . Dumper($type) . "\n"
#        . "\n";
  
    $type->[$i] = $RESIDUE_TYPES{$KNOWN_RESIDUES{$r}{type}};
  }
}

######################################################## KNOWN ATOMS

our @KNOWN_ATOMS = map { @{$_->{aa_atoms}} } values %AA;
push @KNOWN_ATOMS, 'OXT';
our %KNOWN_ATOMS = map { $_ => 1 } @KNOWN_ATOMS;





##############################################################################
#                                     RESIDUE, ANGLE, AND ATOM GROUPS AND SETS
#-----------------------------------------------------------------------------
# An Atom Set is simply that, a named set of atoms, like main chain
# vs side chain atoms.  Similarly for Angle Sets.  An Atom/Angle
# Group, on the other hand, is more of a Grouping, and will 
# generally represent the corresponding set of atoms with a single
# value representing whatever property is being measured (typically an average
# over the value, such as the average B-Factors for a residue). 
#
# All Sets have a corresponding Group, and Groups have one Set.
#
# The Groups have 2-letter names so as to format nicely with other 2-letter
# atom names.  The Sets strictly have 3+-letter names. 
#
# There are also super sets, which are convenience names for 
# specifying a set of GROUPS, taking a residue and breaking it
# down into subsets for output. For instance, MCSC is a Super Set
# that will break the residue down into Main-Chain and Side-Chain 
# Groups. CHI separates out X1-X4 angles. SETS breks out all 
# known (possibly overlapping) groups. 
##############################################################################

our @ANGLE_GROUPS = qw(XX);
our %ANGLE_GROUP_MAP = (
  XX => [qw(X0 X1 X2 X3 X4)],
);
our @ANGLE_SETS = qw(ANG);
our %ANGLE_SET_MAP = (
  ANG => 'XX',
);


our @ATOM_GROUPS = qw(AA MC SC X0 X1 X2 X3 X4);
our @ATOM_SETS   = qw(RES MAIN SIDE CHI0 CHI1 CHI2 CHI3 CHI4);
our @SOLVENT_GROUPS = qw(AA);
our %ATOM_SET_MAP = (
  RES   => 'AA',
  MAIN  => 'MC',
  SIDE  => 'SC',
  CHI0  => 'X0',
  CHI1  => 'X1',
  CHI2  => 'X2',
  CHI3  => 'X3',
  CHI4  => 'X4',
  PHI   => 'PH',
  PSI   => 'PS',
  OMEGA => 'OM',
);

our @ATOM_SUPER  = qw(MCSC CHI CHI0 MCX MCX0 SETS);
our %ATOM_SUPER = (
  MCSC  => [qw(MC SC)],
  CHI   => [qw(X1 X2 X3 X4)],
  CHI0  => [qw(X0 X1 X2 X3 X4)],
  MCX   => [qw(MC X1 X2 X3 X4)],
  MCX0  => [qw(MC X0 X1 X2 X3 X4)],
  SETS  => [@ATOM_GROUPS, @ANGLE_GROUPS],
);

our %ATOM_GROUP_SET_TITLES = (
  RES   => 'Atoms',
  MAIN  => 'Main Chain Atoms', 
  SIDE  => 'Side Chain Atoms',
  CHI   => 'Chi Angles',
  CHI0  => 'Chi 0 Atoms',
  CHI1  => 'Chi 1 Atoms', 
  CHI2  => 'Chi 2 Atoms',
  CHI3  => 'Chi 3 Atoms',
  CHI4  => 'Chi 4 Atoms',
  PHI   => 'Phi Angle Atoms',
  PSI   => 'Psi Angle Atoms',
  OMEGA => 'Omega Angle Atoms',

  AA    => 'Residues',
  MC    => 'Main Chains', 
  SC    => 'Side Chains',
  X0    => 'Chi 0',
  X1    => 'Chi 1', 
  X2    => 'Chi 2',
  X3    => 'Chi 3',
  X4    => 'Chi 4',
  PH    => 'Phi',
  PS    => 'Psi',
  OM    => 'Omega',
);

our %ATOM_GROUPS = ( 
      (map { $_ => 'group' } @ATOM_GROUPS),
      (map { $_ => 'set'   } @ATOM_SETS  ),
      (map { $_ => 'atom'  } @KNOWN_ATOMS),
      (map { $_ => 'super' } @ATOM_SUPER),
      (map { $_ => 'angle' } @ANGLE_GROUPS),
);

#-------- Get Atom Group Components
# TODO: Decide if there is some reason not to return atoms.
# Use this when aggregating data
sub Get_Atom_Group_Components { 
  my $group = $_[0];
  my $resn  = $_[1];
  my $atoms = $_[2] || [];
  my $type = $ATOM_GROUPS{$group};

  # User passed a real atom
  if ( grep { $_ eq $group } @$atoms ) { return $group }
  
  if ( not defined $type ) { confess "Unknown atom group '$group'.\n" }
  if ( $type eq 'set'    ) { return () }
  if ( $type eq 'super'  ) { return () }
  if ( $type eq 'atom'   ) { return $group }
  if ( $type eq 'angle'  ) { return @{$ANGLE_GROUP_MAP{$group}} }
  if ( $type eq 'group'  ) { 
    my $ga = lc "$group\_atoms";
    if ( exists $KNOWN_RESIDUES{$resn}{$ga} ) { 
      return @{$KNOWN_RESIDUES{$resn}{$ga}};
    } else { 
      if ( (uc $group) eq 'AA' ) { 
        return Utility::Difference($atoms, [@ATOM_GROUPS, @ATOM_SETS]);
      } else { 
        return ();
      }
    }
  }
  croak "Unknown group type '$group' '$type'.\n";
}

#-------- Get Atom Set Elements
# Use this when displaying sets of data
sub Get_Atom_Set_Elements { 
  my $group = $_[0];
  my $resn  = $_[1];
  my $atoms = $_[2] || [];
  my $type = $ATOM_GROUPS{$group};
  
  if ( not defined $type ) { confess "Unknown atom set '$group'.\n" }
  if ( $type eq 'group'  ) { return ($group)                        }
  if ( $type eq 'super'  ) { return @{$Utility::ATOM_SUPER{$group}} }
  if ( $type eq 'angle'  ) { return @{$ANGLE_GROUP_MAP{$group}} }
  if ( $type eq 'atom'   ) { return ($group)                        }
  if ( $type eq 'set'    ) { 
    my $ga = lc ($ATOM_SET_MAP{$group} . "_atoms");
    if ( exists $KNOWN_RESIDUES{$resn}{$ga} ) { 
      return @{$KNOWN_RESIDUES{$resn}{$ga}};
    } else { 
      if ( (uc $group) eq 'RES' ) { 
        return Utility::Difference($atoms, [@ATOM_GROUPS, @ATOM_SETS]);
      } else { 
        return ();
      }
    }
  }
  confess "Unknown group type '$group' '$type'.\n"
    . Dumper (\%ATOM_GROUPS);
}

################################################### IS HYDROGEN ATOM
sub Is_Hydrogen_Atom {
  my $atom = $_[0];
  return 1 if $atom =~ /^H/;
  return 1 if $atom =~ /^\d/;
  return 0;
}

##############################################################################
#                                             ATOM NAME TRANSLATIONS
#-------------------------------------------------------------------
# NOTE: It appears that, as written, I can't actually access 
# hydrogen atom names in a standardized way, as they're either the 
# original name or they're just 'H', depending on which lookup I 
# use. I should probably fix that at some point. Will rewrite the 
# PDB_Parse_Atom_line to warn when these are encountered so I can 
# accumulate some references and fix this.  On further inspection, 
# it appears that all but the last hydrogen are simply overwritten.
# SMRT. CONFIRMED.
#
# All the residue and atom types we know should be pushed into here.
# If a residue isn't a known type, we shouldn't check it's atom 
# types, as they may have different conventions (particularly for 
# ligands).
##############################################################################

# TODO: Delete this cruft. It's very ilmm tailored anyway

our %ATOM_NAME_TRANSLATION_OPTIONS = (
  C   =>[qw(C   )],  CA  =>[qw(CA  )],  CB  =>[qw(CB  )],
  CG  =>[qw(CG  )],  CD  =>[qw(CD  )],  CD1 =>[qw(CD1 )],
  CD2 =>[qw(CD2 )],  CE  =>[qw(CE  )],  CE1 =>[qw(CE1 )],  
  CE2 =>[qw(CE2 )],  CE3 =>[qw(CE3 )],  CG  =>[qw(CG  )],  
  CG1 =>[qw(CG1 )],  CG2 =>[qw(CG2 )],  CH2 =>[qw(CH2 )],  
  CZ  =>[qw(CZ  )],  CZ2 =>[qw(CZ2 )],  CZ3 =>[qw(CZ3 )],
   
  N   =>[qw(N   )],  ND1 =>[qw(ND1 )],  ND2 =>[qw(ND2 )],
  NE  =>[qw(NE  )],  NE1 =>[qw(NE1 )],  NE2 =>[qw(NE2 )],  
  NH1 =>[qw(NH1 )],  NH2 =>[qw(NH2 )],  NZ  =>[qw(NZ  )],    
    
  O   =>[qw(O   )],  OD1 =>[qw(OD1 )],  OD2 =>[qw(OD2 )],
  OE1 =>[qw(OE1 )],  OE2 =>[qw(OE2 )],  OG  =>[qw(OG  )],
  OG1 =>[qw(OG1 )],  OH  =>[qw(OH  )],  OXT =>[qw(OXT )],
  
  SD  =>[qw(SD  )],  SG  =>[qw(SG  )],

  H   =>[qw(H    HA   HA1  HA2  HB   HB1  HB2  HB3  HD1  HD11 
            HD12 HD13 HD21 HD22 HD23 HE   HE1  HE2  HE21 HE22 
            HE3  HG   HG1  HG11 HG12 HG13 HG2  HG21 HG22 HG23 
            HH   HH11 HH12 HH2  HH21 HH22 HS   HZ   HZ1  HZ2  HZ3 
            1HH1 2HH1 1HH2 2HH2 1HE2 2HE2 1HZ  2HZ  3HZ  1HD1 
            2HD1 3HD1 1HD2 2HD2 3HD2 1HA  2HA  1HB  2HB  3HB 
            1HG  2HG  1HD  2HD  1HG1 2HG1 3HG1 1HG2 2HG2 3HG2 
            1HE  2HE  3HE  1H   2H   3H   1HT  2HT  3HT)],
);

our %ATOM_NAME_TRANSLATION_LOOKUP = ();
foreach my $main ( keys %ATOM_NAME_TRANSLATION_OPTIONS ) {
  foreach my $alias ( @{$ATOM_NAME_TRANSLATION_OPTIONS{$main}} ) { 
    if ( $main eq 'H' ) { 
      $ATOM_NAME_TRANSLATION_LOOKUP{$alias} = $alias;
    } else { 
      $ATOM_NAME_TRANSLATION_LOOKUP{$alias} = $main;
    }
  }
}

sub Lookup_Atom_Name { 
  my $res = $_[0];
  my $atom = $_[1];
  if ( not exists $KNOWN_RESIDUES{PROTEIN}{$res} ) { return $atom }
  my $conv = $ATOM_NAME_TRANSLATION_LOOKUP{$atom};
  if ( not defined $conv ) { return $atom }
  return $conv;
}


######################################## ATOM ORDER FOR WRITING PDBS

our %ATOM_ORDER = (
  ALA => [ qw(N H H2 H3 CA HA CB HB1 HB2 HB3 C O OXT) ],
  ARG => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG HG1 HG2 CD HD1 HD2 NE HE CZ NH1 HH11 HH12 NH2 HH21 HH22 C O OXT) ],
  ASP => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG OD1 OD2 C O OXT) ],
  ASH => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG OD1 OD2 HO C O OXT) ],
  ASN => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG OD1 ND2 HD21 HD22 C O OXT)],
  CYS => [ qw(N H H2 H3 CA HA CB HB1 HB2 SG C O OXT)],
  CYH => [ qw(N H H2 H3 CA HA CB HB1 HB2 SG HS C O OXT)],
  GLU => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG HG1 HG2 CD OE1 OE2 C O )],
  GLH => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG HG1 HG2 CD OE1 OE2 HO C O OXT)],
  GLN => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG HG1 HG2 CD OE1 NE2 HE21 HE22 C O OXT)],
  GLY => [ qw(N H H2 H3 CA HA1 HA2 C O OXT)],
  HIN => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG ND1 CE1 HE1 NE2 CD2 HD2 C O OXT)],
  HIS => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG ND1 HD1 CE1 HE1 NE2 CD2 HD2 C O OXT)],
  HID => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG ND1 HD1 CE1 HE1 NE2 CD2 HD2 C O OXT)],
  HIE => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG ND1 CE1 HE1 NE2 HE2 CD2 HD2 C O OXT)],
  HIP => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG ND1 HD1 CE1 HE1 NE2 HE2 CD2 HD2 C O OXT)],
  ILE => [ qw(N H H2 H3 CA HA CB HB CG2 HG21 HG22 HG23 CG1 HG11 HG12 CD1 HD11 HD12 HD13 C O OXT)],
  LEU => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG HG CD1 HD11 HD12 HD13 CD2 HD21 HD22 HD23 C O OXT)],
  LYS => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG HG1 HG2 CD HD1 HD2 CE HE1 HE2 NZ HZ1 HZ2 HZ3 C O OXT)],
  MET => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG HG1 HG2 SD CE HE1 HE2 HE C O OXT)],
  PHE => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG CD1 HD1 CE1 HE1 CZ HZ CE2 HE2 CD2 HD2 C O OXT)],
  PRO => [ qw(N H H2 H3 CA HA1 CB HB1 HB2 CG HG1 HG2 CD HD1 HD2 C O OXT)],
  SER => [ qw(N H H2 H3 CA HA CB HB1 HB2 OG HG C O OXT)],
  THR => [ qw(N H H2 H3 CA HA CB HB OG1 HG1 CG2 HG21 HG22 HG23 C O OXT)],
  TRP => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG CD1 HD1 NE1 HE1 CE2 CZ2 HZ2 CH2 HH2 CZ3 HZ3 CE3 HE3 CD2 C O OXT)],
  TYR => [ qw(N H H2 H3 CA HA CB HB1 HB2 CG CD1 HD1 CE1 HE1 CZ OH HH CE2 HE2 CD2 HD2 C O OXT)],
  VAL => [ qw(N H H2 H3 CA HA CB HB CG1 HG11 HG12 HG13 CG2 HG21 HG22 HG23 C O OXT)],

  GLC => [ qw(C1 H1 C2 H2 C3 H3 O3H H3O C4 H4 O4H H4O C5 H5 OR N15 H29 C7 OM C8 H8 H8S H8R C6 H6S H6R O6H H6O)],
  MAN => [ qw(C1 H1 C2 H2 O2H H2O C3 H3 O3H H3O C4 H4 O4H H4O C5 H5 OR C6 H6S H6R O6H H6O)],
  GAL => [ qw(C1 H1 C2 H2 O2H H2O C3 H3 C4 H4 O4H H4O C5 H5 OR C6 H6S H6R O6H H6O)],
  NEU => [ qw(C2 C3 H3 H21 C4 H4 O4H H4O C5 H5 C6 H6 OR C1 OM1 OM2 N H37 C34 OM C35 H35 H39 H48 C7 H7 O7H H7O C8 H8 O8H H8O C9 H9S H9R O9H H9O)],
  FUC => [ qw(C1 H1 C2 H2 O2H H2O C3 H3 O3H H3O C4 H4 O4H H4O C5 H5 C6 H6 H6S H6R OR)],

  MN2 => [ qw(C2 H2 O2H H2O C3 H3 O3H H3O C4 H4 O4H H4O C5 H5 OR C1 H1 C6 H6S H6R O6H H6O)], 
  MN6 => [ qw(C6 H6S H6R C5 H5 OR C1 H1 C2 H2 C3 H3 O3H H3O C4 H4 O4H H4O)],
  ETO => [ qw(N HN C2 H21 H22 C1 H11 H12 O)],
  ETC => [ qw(O C1 H11 H12 C2 H21 H22 N HN1 HN2)],
  NEB => [ qw(OR C1 OM CO2 O2H H2O C3 H3 H21 C4 H4 O4H H4O C5 H5 C6 H6 OW C7 H7 O7H H7O C8 H8 O8H H8O C9 H9R H9S O9H H9O N33 H37 C34 OM2 C35 H35 H39 H40)],
  MIN => [ qw(06L C6 H6 C1 H1 O1P C2 H2 O2H H2O C3 H3 O3H H3O C4 H4 O4H H4O C5 H5 O5H H5O)],
  POO => [ qw(P OP1 OP2)],
  CER => [ qw(O3 C3 H3A H3B C2 H2 O2 C1 H1A H1B O1)],
  GCN => [ qw(C4 H4 C5 H5 OR C1 H1 C2 H2 N23 H24 H25 C3 H3 O3H H3O C6 H6S H6R O6H H6O)],
  STE => [ qw(C1 OM C2 H2A H2B C3 H3A H3B C4 H4A H4B C5 H5A H5B C6 H6A H6B C7 H7A H7B C8 H8A H8B C9 H9A H9B C10 H0S H0R C11 H1S H1R C12 H2S H2R C13 H3S H3R C14 H4S H4R C15 H5S H5R C16 H6S H6R C17 H7S H7R C18 H8S H8R H8Q)],

  POP => [ qw(N50 C47 1H47 2H47 3H47 C48 1H48 2H48 3H48 C49 1H49 2H49 3H49 C46 1H46 2H46 C45 1H45 2H45 O44 P43 O51 O52 O23 C21 1H21 2H21 C20 H20 C19 1H19 2H19 O17 C16 O18 C13 1H13 2H13 C12 1H12 2H12 C11 1H11 2H11 C10 1H10 2H10 C9 1H9 2H9 C8 1H8 2H8 C7 1H7 2H7 C4 1H4 2H4 C3 1H3 2H3 C5 1H5 2H5 C2 1H2 2H2 C1 1H1 2H1 C6 1H6 2H6 C14 1H14 2H14 C15 1H15 2H15 3H15 O22 C24 O25 C32 1H32 2H32 C31 1H31 2H31 C30 1H30 2H30 C29 1H29 2H29 C28 1H28 2H28 C27 1H27 2H27 C26 1H26 2H26 C33 H33 C34 H34 C42 1H42 2H42 C41 1H41 2H41 C40 1H40 2H40 C39 1H39 2H39 C38 1H38 2H38 C37 1H37 2H37 C36 1H36 2H36 C35 1H35 2H35 3H35)],

);










#################################### CONVERT DEGREE TO Range 0 : 360
sub convert_to_180_centered {return ($_[0]%360);}

################################# CONVERT DEGREE TO Range -180 : 180
sub convert_to_0_centered {return ($_[0]>180 ? ($_[0]-360) : $_[0]);}




##############################################################################
#                                                     SET OPERATIONS
##############################################################################



########################################################################## SUM
sub Sum {
  return 0 if not scalar @_;
  my $array;
  if ( ref ($_[0]) eq 'ARRAY' ) { $array = $_[0] }
  else                          { $array = \@_   }

  my $x=0; 
  map { $x+=$_ } grep { $_ } @$array; 
  return $x; 
}

########################################################################## MAX
sub Max {

  my @numbers = Flatten(@_);

  # Take the actual maximum
  my $max;
  foreach (@numbers) {
    next if not defined $_;
    next if $_ eq 'NA';
    if ( not defined $max or $max < $_ ) { 
      $max = $_;
    }
  }
  
  return $max;
} 

########################################################################## MIN
sub Min {
  
  my @numbers = Flatten(@_);
    
  # Take the actual maximum
  my $min;
  foreach (@numbers) {
    next if not defined $_;
    next if $_ eq 'NA';
    if ( not defined $min or $min > $_ ) { 
      $min = $_;
    }
  }
  
  return $min;
} 



####################################################################### UNIQUE
# Takes an array (or array ref) and returns the unique elements. Elements
# are kept in the same order as input.

sub Unique {
  return if not @_;

  my %unique = ();
  my @unique = ();
  foreach my $e ( (ref $_[0] eq 'ARRAY') ? @{$_[0]} : @_ ) { 
  #foreach my $e ( (ref $_[0] eq 'ARRAY') ? @$$_[0] : @_ ) { 
    next if not defined $e;
    if ( not exists $unique{$e} ) { 
      push @unique, $e;
      $unique{$e} = 1;
    }
  }
  if ( wantarray ) { return  @unique } 
  else             { return \@unique }


  #my %int = ();
  #if ( ref $_[0] eq 'ARRAY' ) { map { $int{$_} = 1 } @{$_[0]} }
  #else                        { map { $int{$_} = 1 } @_ }
  #if ( wantarray ) { return sort keys %int } 
  #else             { return [sort keys %int] }
}

################################################################ UNIQUE COUNTS
# Get the unique set of elements, and then count the occurances of each
# element in the list.
sub Unique_Counts { 
  return if not @_;
  my $list = ();
  if ( ref $_[0] eq 'ARRAY' ) { $list = $_[0] }
  else                        { $list = \@_   }

  my $unique = Unique($list);
  my $counts = ();

  foreach my $i ( 0..$#$unique ) { 
    my $u = $unique->[$i];
    my $c = scalar grep { $u eq $_ } @$list;
    $counts->[$i] = $c;
  }
  return ($counts, $unique);
}


#################################################################### SET UNION
sub Union {
  my $set1  = $_[0];
  my $set2  = $_[1];
  my $num   = $_[2] || 0;

  my $union = Unique(@$set1, @$set2);

  if ( wantarray ) { return @$union }
  else             { return  $union }
}

#################################################################### IS IN SET
sub Is_In_Set { 
  my $set   = $_[0] || return 0;
  my $value = $_[1];
  if ( not defined $value ) { confess "No value passed" }
  my $type  = Is_Number($value) ? 'NUMBER' : 'STRING';
  my $found = 0;
  
  if ( $type eq 'NUMBER' ) { 
    foreach my $elem ( @$set ) { 
      if ( $value == $elem ) { return 1 }
    }
  } else { 
    foreach my $elem ( @$set ) { 
      if ( $value eq $elem ) { return 1 }
    }
  }

  return 0;
}
   
############################################################## SET INTERSECTION
sub Intersection {

  my $set1  = $_[0];
  my $set2  = $_[1];
  my $num   = $_[2] || 0;

  my @set = ();

  if ( $num ) {
    for my $x ( @$set1 ) {
      if ( grep { $x == $_ } @$set2 ) { 
        push @set, $x;
      }
    }
  } else { 
    for my $x ( @$set1 ) {
      if ( grep { $x eq $_ } @$set2 ) { 
        push @set, $x;
      }
    }
  }
  #confess Dumper ( @set );
  if ( wantarray ) { return @set; }
  else             { return \@set; }
}

################################################################ SET DIFFERENCE
sub Difference {

  my $set1  = $_[0];
  my $set2  = $_[1];
  my $num   = $_[2] || 0;

  my @set = ();
  if ( $num ) {
    for my $x ( @$set1 ) {
      if ( not grep { $x == $_ } @$set2 ) { 
        push @set, $x;
      }
    }
  } else { 
    for my $x ( @$set1 ) {
      if ( not grep { $x eq $_ } @$set2 ) { 
        push @set, $x;
      }
    }
  }
  if ( wantarray ) { return @set; }
  else             { return \@set; }
}

################################################################## SET IDENTITY
sub Identical_Arrays {

  my $set1 = $_[0] || [];
  my $set2 = $_[1] || [];
  my $comp = $_[2];

  #my @set1 = sort @$set1;
  #my @set2 = sort @$set2;

  #=============== Sets are not the same size
  if ( scalar @$set1 != scalar @$set2 ) { 
    return 0
  }

  #=============== Guess what comparison to use 
  if ( not defined $comp ) { 
    my $value = $set1->[0];
    if (Is_Number($value)) { $comp = 'numeric' }
    else                   { $comp = 'alphabetical' }
  }

  #=============== Compare the sets
  foreach my $i ( 0..$#$set1 ) { 
    
    #----------- Both defined or not defined 
    if   ( not defined $set1->[$i] ) { 
      if (     defined $set2->[$i] ) { return 0 }
      else                         { next     }
    } else { 
      if ( not defined $set2->[$i] ) { return 0 }
    }

    #----------- Make comparison
    if ( $comp eq 'numeric' ) { 
      if ( $set1->[$i] != $set2->[$i] ) { return 0 }
    } else { 
      if ( $set1->[$i] ne $set2->[$i] ) { return 0 }
    }
  }
  return 1

}

##############################################################################
##############################################################################
#                                                                   HISTOGRAMS
##############################################################################
##############################################################################

###################################################################### GET BIN
sub Get_Degree_Bin {
  return POSIX::floor( ($_[0] % 360) / $_[1]);
}
sub get_bin { confess "This subroutine is gone" }


#################################################################### HISTOGRAM
# Options List
#   min       | lower bound on histogram
#   max       | upper bound on histogram
#   bins      | number of bins to set histogram to
#   width     | width of each histogram bin (overrides bins)
#   circular  | if value outside min/max, mod it by range to get within bounds
#   condense  | if value outside min/max, put it in low/high bin
#             | if min/max are set, but not circular or condense, then values
#             | outside that range are simply ignored
#


sub Histogram { 
  my $data = $_[0];
  my $options = $_[1] || {};

  #-- Get/Set Min/Max/Range
  my $min_data    = $options->{min} || Min($data);
  my $max_data    = $options->{max} || Max($data);
  my $range_data  = $max_data - $min_data;

  #-- Get/Set Bin Counts and Bin Width
  my $bins        = $options->{bins};
  my $width       = $options->{width};
  my $min_bin;
  my $max_bin;

  if ( not defined $bins ) { 
    if ( not defined $width ) { $width = 1.0 } 
    $bins  = POSIX::ceil($range_data / $width);
  } else { 
    if ( not defined $width ) { 
      $width = $range_data / $bins;
      $min_bin = $min_data;
      $max_bin = $max_data - $width;
    } else { # override bins
    $bins  = POSIX::ceil($range_data / $width);
    #  $bins  = (POSIX::ceil($max_data) - POSIX::floor($min_data)) / $width;
    }
  }

  #-- Min/Max Bin are the floor values for the respective histogram bins
  if ( not defined $min_bin ) { 
    $min_bin = Math::Round::nlowmult($width, $min_data);
    $max_bin = Math::Round::nlowmult($width, $max_data);
  }

  #-- Decicularize and Condense Data
  if ( $options->{cicular } ) { Decircularize_Array($data, $min_data, $max_data) }
  if ( $options->{condense} ) { Condense_Array     ($data, $min_data, $max_data) }

  #-- Create Histogram, Initialized to 0
  my @H = (0) x $bins;
  my $bin;
  foreach my $d ( @$data ) { 
    $bin = POSIX::floor(($d-$min_bin) / $width);
    $H[$bin]++;
  }
  return \@H;
}

########################################################## DECIRCULARIZE ARRAY
# Assuming a circular data value, use modular arithmatic to keep a datapoint
# in a certain range. Rather than just modding though, can use whatever
# window on the modular group you want. So dihedral angles could be expressed
# as 0 to 360 degrees or -180 to 180 degrees. Use min and max to calculate the
# range desired.
# NOTE: array is edited in place
# NOTE: min/max might not be centered around 0. I don't handle that case yet.

sub Decircularize_Array { 
  my $data  = $_[0];
  my $min   = $_[1];
  my $max   = $_[2];
  my $range = $max-$min;
  
  foreach my $i ( 0..$#$data ) { 
    my $d = $data->[$i];
    next if $d >= $min and $d <= $max; # Value is good
    $d %= $range; # Mod it to bring it to standard value

    if ( $d < $min ) { $d += $range } 
    if ( $d > $max ) { $d -= $range } 
  }
}

############################################################### CONDENSE ARRAY
# Given an array and target min/max values, move every value in the array
# less than min to min, and greater than max to max.
# NOTE: array is edited in place

sub Condense_Array { 
  my $data  = $_[0];
  my $min   = $_[1];
  my $max   = $_[2];
  
  foreach my $i ( 0..$#$data ) { 
    if ( $data->[$i] < $min ) { $data->[$i] = $min } 
    if ( $data->[$i] > $max ) { $data->[$i] = $max } 
  }
}


############################################################### MAKE HISTOGRAM
# NOTE: Am leaving this one along and replacing it with the subroutine above.
# Make a histogram from an array of data with a specified binwidth.
# TODO: set standard minimum values and other options.
# Fortunately this subroutine is so lame I never used it, so can fix it.

sub Make_Histogram { 

  my $data = $_[0];
  my $binwidth = $_[1] || 1;

  my $min = POSIX::floor(Min($data));
  $min -= $min % $binwidth;

  my @hist = ();

  foreach my $d (@$data) { $hist[POSIX::floor($d-$min)/$binwidth]++; }

  if ( wantarray ) { return @hist }
  else             { return \@hist }

}


########################################################## MAKE LOGX HISTOGRAM
# Converts a linear histogram into a logrithmic one, with the base specified.
# Only works on histograms with binwidth 1 and minimum value of 1.0
# There are two bin profile options, we're using the first one:
#         USING -> BINS I: base^I     <= X <  base^(I+1)
#     NOT USING -> BINS I: base^(I-1) <  X <= base^I
# This profile makes more intuitive sense, given that we only deal with 
# numbers >= 1 in this histogram.  To find the right bin I in base B for sample X:
#     I = FLOOR(log(X)/log(B))

sub Make_LogX_Histogram {
  my $hist    = $_[0];
  my $base    = $_[1];
  my $options = $_[2] || {};

  #-- Get/Set Min/Max/Range
  my $min_data    = $options->{min} || 1;
  my $max_data    = $options->{max} || scalar @$hist;
  my $range_data  = $max_data - $min_data;

  #-- Get/Set Bin Counts and Bin Width
  # Only make sense for a linear histogram. Should have filtered it already.
  #my $bins        = $options->{bins};
  #my $width       = $options->{width};
  #my $min_bin;
  #my $max_bin;



  if ( not $hist or not scalar @$hist ) { return ( wantarray ? () : [] ) }

  # Initialize array
  my $length = POSIX::floor( log ( scalar @$hist ) / log ( $base ) );
  my @new = (0) * $length;

  #print "Length = $length\n";



  #=============== Add sums for each slot
  foreach my $i ( 0..$#$hist ) {
    my $value = $i + $min_data;
    my $count = $hist->[$i] || 0;
    #------------- Special case, add all [0,1) values to bin 0
    if ( $value < 1 ) { 
      $new[0] += $count;
      next;
    }
    #------------- Calculate Bin
    my $bin = POSIX::floor(log($value) / log($base));
    $new[$bin] += $count;
  }


#    #if ( not defined $hist->[$i] ) { $hist->[$i] = 0 }
#    $new[0] = $hist->[0] // 0;
#    if ( not defined $hist->[$i] ) { next }
#    $new [ POSIX::floor ( log($i) / log($base) ) ] += $hist->[$i];
#  }

#  # Normalize sums by width
#  foreach my $i ( 2..$length ) { 
#    $new[$i] /= (2**$i) / 2;
#  }

  # Return new array 
  if (wantarray)  { return @new  }
  else            { return \@new }
}

sub Mean_and_Stddev {

  my $array = $_[0];
  if ( not ref $array eq 'ARRAY' ) { $array = \@_ }
  
  my $count = scalar(grep { defined $_ } @$array);
  return (0,0) if 0 == $count;
  return ($array->[0], 0) if 1 == $count;

  my $sum = 0;
  my $mean = 0;
  my $stddev = 0;
  
  
  $sum = Sum ( $array );
  $mean = $sum / $count;
  foreach ( @$array ) {
    next if not defined $_;
    $stddev += ($mean-$_)**2;
  }
  #$stddev /= $count;
  $stddev = sqrt ( $stddev / $count );
  #print "M: $mean  S: $sum  SD: $stddev  C: $count\n";
  return ($mean, $stddev);
}


sub Hist_Mean_and_Stddev {
  my $hist = $_[0];
  
  my $mean = 0;
  my $stddev = 0;
  my $changes = 0;
  my $total = 0;
  
  for my $i ( 0..$#$hist ) {
    if ( not defined $hist->[$i] ) { $hist->[$i] = 0; }
    $changes += $hist->[$i];
    $total += $hist->[$i] * $i;
    $mean += $hist->[$i] * $i; 
  }
  
  if ( $changes == 0 ) { return (0,0,0) };
  $mean /= $changes;

  for my $i ( 0..$#$hist ) {
    $stddev += (($i-$mean)**2) * $hist->[$i];
  }
  $stddev = sqrt ( $stddev / $changes );

  return ($mean, $stddev, $changes, $total);
}


####################################################################### MEDIAN

sub Median {

  my $array       = $_[0];
  my $percentiles = $_[1] || [50];

  # Passed a scaler, turn it into an array
  if ( ref $percentiles eq '' ) { $percentiles = [ $percentiles ] }

  # Sort the array and get the length
  my @sorted = sort { $a <=> $b } grep { defined $_ and $_ ne 'NA' } @$array;
  my $length = scalar @sorted;

  # Convert the percentiles into indices into the array
  my @indices = map { sprintf "%.0f", $length * $_ / 100.0 } @$percentiles;

  #print Dumper($array);
  foreach my $i ( 0..$#indices ) { 
    if ( $indices[$i] >= $length ) { 
      $indices[$i] = $length-1;
    }
    #print "I: $i IDX: $indices[$i] %: $percentiles->[$i] V: $sorted[$indices[$i]]\n";
  }

  # Return the percentiles
  my @pcnt = map { $sorted[$_] } @indices;
  return ( wantarray ? @pcnt : \@pcnt );
}


 
sub RMSD { 

  my $a1 = $_[0];
  my $a2 = $_[1];

  my $length1 = scalar @$a1;
  my $length2 = scalar @$a2;
  if ( $length1 != $length2 ) { 
    confess "Utility::RMSD :: Arrays 1 and 2 are not the same length ($length1 vs. $length2)";
  }
  
  my $rmsd = 0;

  foreach my $i ( 0..($length1-1) ) { 

    my $v1 = $a1->[$i];
    my $v2 = $a2->[$i];

    next if not defined $v1;
    next if not defined $v2;

    my $d1 = $v2-$v1;
    my $d2 = $d1*$d1;

    $rmsd += $d2;
  }

  $rmsd /= $length1;
  $rmsd = sqrt($rmsd);

  return $rmsd;
}
  

sub Correlation {

  my $a1 = $_[0];
  my $a2 = $_[1];

  if ( not ref $a1 eq 'ARRAY' ) { confess "Utility::Correlation !! First argument is not an array ref" }
  if ( not ref $a2 eq 'ARRAY' ) { confess "Utility::Correlation !! Second argument is not an array ref" }

  if ( scalar @$a1 != scalar @$a2 ) { 
    confess "Utility::Correlation: arrays are not the same length.";
  }

  my @a1p = ();
  my @a2p = ();
  foreach my $i ( 0..$#$a1 ) { 
    next if not defined $a1->[$i];
    next if not defined $a2->[$i];
    push @a1p, $a1->[$i];
    push @a2p, $a2->[$i];
  }
    
  my ($m1, $s1) = Mean_and_Stddev(\@a1p);
  my ($m2, $s2) = Mean_and_Stddev(\@a2p);

  if ( $s1 == 0 or $s2 == 0 ) { return 0 }

  my $cov = 0;
  my $cnt = 0;
  foreach my $i (0..$#a1p) { 
    $cnt++;
    $cov += ( $a1p[$i] - $m1 ) * ( $a2p[$i]-$m2 );
  }
  $cov /= $cnt;

  my $cor = $cov / $s1 / $s2;
  #print "M: $m1/$m2  SD: $s1/$s2  COV: $cov  COR: $cor\n";
  return $cor;

}


sub Displacement_Raw{ 
  my $a1 = $_[0];
  my $a2 = $_[1];
 
  if ( not defined $a1 ) { confess "Utility::Displacement: array1 undefined." }
  if ( not defined $a2 ) { confess "Utility::Displacement: array2 undefined." }
  
  if ( scalar @$a1 != scalar @$a2 ) { 
    confess "Utility::Displacement: arrays are not the same length.";
  }

  my $s = 0;

  foreach my $i ( 0..$#$a1 ) { 
    $s += abs($a1->[$i]-$a2->[$i]); 
  }

  return $s;

}



sub Displacement { 

  my $a1 = $_[0];
  my $a2 = $_[1];

  if ( scalar @$a1 != scalar @$a2 ) { 
    confess "Utility::Displacement: arrays are not the same length.";
  }

  my $s = 0;
  my $t1 = 0;
  my $t2 = 0;

  foreach my $i ( 0..$#$a1 ) { 
    #next if not defined $a1->[$i];
    #next if not defined $a2->[$i];
    $t1 += $a1->[$i];
    $t2 += $a2->[$i];
    $s += Utility::Min($a1->[$i], $a2->[$i]);
  }

  if ( abs($t1 - $t2) > 0.00001 ) { 
    confess "Utility::Displacement: arrays are not the same total ($t1 vs $t2).";
  }

  my $d = 1 - ($s/$t1);
  return $d;

}


sub Histogram_Shift_Min_to_X { 
    my $hist = $_[0];
    my $shift = $_[1] || 0;
    my $min = Min ( $hist ) - $shift;
    foreach my $i ( 0..$#$hist ) { 
        $hist->[$i] -= $min;
    }
}

sub Normalize_Histogram {

  my $hist = $_[0];
  my $sum = Sum ( $hist );
  return if not $sum;
  foreach my $i ( 0..$#$hist ) {
    if ( defined $hist->[$i] ) { $hist->[$i] /= $sum;}
  }
}

# This particular normalization doesn't normalize the histogram by counts, 
# but rather by the amount of time spent in a bin. The bin itself indicates
# the size of the bin, so the fraction population in that bin becomes the 
# count multiplied by the size of the bin.  Note that you cannot normalize
# this array multiple times like you can with the Normalize_Histogram
# subroutine.
sub Normalize_Histogram_to_Population { 
  my $hist = $_[0];
  
  # Find total population
  my $sum = 0;
  foreach my $i ( 0..$#$hist ) { 
    if ( defined $hist->[$i] ) { $sum += $hist->[$i] * $i };
  }
  return if $sum == 0;

  # Normalize in place
  foreach my $i ( 0..$#$hist ) { 
    if ( defined $hist->[$i] and $hist->[$i] > 0 ) { 
      $hist->[$i] = $hist->[$i] * $i / $sum;
    }
  }
}

sub Normalize_Histogram_2D {

  my $hist = $_[0];
  my $sum = Sum_Histogram_2D ( $hist );
  return if not $sum;
  foreach my $i ( 0..$#$hist ) {
    next if not defined $hist->[$i];
    foreach my $j ( 0..$#{$hist->[$i]} ) {
      next if not defined $hist->[$i][$j];
      next if not $hist->[$i][$j];
      $hist->[$i][$j] /= $sum;
    }
  }
}

sub Zero_Blanks_In_Histogram {

  my $hist = $_[0];
  foreach (0..$#$hist ) { 
    $hist->[$_] = 0 if not defined $hist->[$_];
  }
}

sub Rebin_Histogram { 

  my $hist = $_[0];
  my $bin = $_[1];

  my @new = ();
  for my $i ( 0..$#$hist ) {
    $new[ POSIX::floor($i/$bin) ] += $hist->[$i];
  }
  if ( wantarray ) { return @new }
  else             { return \@new }
}

sub Combine_Histograms {

  my $agg       = $_[0];
  my $data      = $_[1];
  my $agg_mult  = $_[2] || 1;
  my $data_mult = $_[3] || 1;

  my $max = Max ( [$#$data, $#$agg] );
  foreach my $i ( 0..$max ) {

    if ( not defined $data->[$i] ) {
      if ( not defined $agg->[$i] ) {
        next;
      } else {
        $agg->[$i] *= $agg_mult;
        next;
      }
    } else {
      if ( defined $agg->[$i] ) { 
        $agg->[$i] = $agg->[$i] * $agg_mult + $data->[$i] * $data_mult; 
      } else                      { 
        $agg->[$i] = $data->[$i] * $data_mult; 
      }
    }
  }
}

sub Combine_Histograms_2D {
  my $agg  = $_[0];
  my $data = $_[1];
  my $agg_mult = $_[2] || 1;
  my $data_mult = $_[3] || 1;

  my $max_x = Max ( [$#$data, $#$agg] );

  foreach my $i ( 0..$max_x ) {
    my $max_y = Max ( [$#{$data->[$i]}, $#{$agg->[$i]}] );
    foreach my $j ( 0..$max_y ) {
      if ( not defined $data->[$i][$j] ) {
        if ( not defined $agg->[$i][$j] ) { 
          next;
        } else {
          $agg->[$i][$j] *= $agg_mult;
        }
      } else {
        if ( defined $agg->[$i][$j] ) { 
          $agg->[$i][$j] = $agg->[$i][$j] * $agg_mult + $data->[$i][$j] * $data_mult; 
        } else {
          $agg->[$i][$j] = $data->[$i][$j] * $data_mult; 
        }
      }
    }
  }
}

# No error checking
sub Combine_Histograms_2D_Fast {
  my $agg  = $_[0];
  my $data = $_[1];
  my $agg_mult = $_[2] || 1;
  my $data_mult = $_[3] || 1;

  my $d;

  foreach my $i ( 0..$#$data ) {
    next if not defined $data->[$i];
    foreach my $j ( 0..$#{$data->[$i]} ) {
      next if not defined $data->[$i][$j];
      next if not ($d = $data->[$i][$j]);
      #print "$i $j $d\n";
      $agg->[$i][$j] = $agg->[$i][$j] * $agg_mult + $d * $data_mult; 
    }
  }
}

sub Zero_Histogram_2D {
  my $hist = $_[0];
  foreach my $i ( 0..$#$hist ) { 
    next if not defined $hist->[$i];
    foreach my $j ( 0..$#{$hist->[$i]} ) { 
      next if not defined $hist->[$i][$j];
      next if not $hist->[$i][$j];
      $hist->[$i][$j] = 0;
    }
  }
}



##################################################### COPY HISTOGRAM

sub Copy_Histogram {}
sub Copy_Histogram_2D {}



###################################################### SUM HISTOGRAM

sub Sum_Histogram {
  my $hist = $_[0];
  return Sum ( $hist );
}

sub Sum_Histogram_2D {
  my $hist = $_[0];
  return Sum ( [ map { Sum ( $_ ) } @$hist ] );
}



##############################################################################
##############################################################################
#                                                                   STATISTICS
##############################################################################
##############################################################################

######################################################### CALCULATE STATISTICS
# Options
#   hist      | data is actually a histogram
#   width     | histogram bin width
#   base      | minimum value for histogram
#

sub Calculate_Distribution_Statistics {
  
  return if not @_;

  my @list = @{$_[0]};
  my %parm = (defined $_[1]) ? %{$_[1]} : ();

  my $hist     = exists $parm{hist    } ? $parm{hist    } : 0;
  my $binwidth = exists $parm{binwidth} ? $parm{binwidth} : 1;
  my $base     = exists $parm{base    } ? $parm{base    } : 0;
  my $pcnts_i  = $parm{pcnts};

  # Default percentiles 
  if ( not defined $pcnts_i ) { 
    $pcnts_i = [ 10, 25, 50, 75, 90 ];
  }

  #print join ',', @list;
  #print "\n";

  #----- Variables
  my $count   = 0;
  my $mean    = 0;
  my $stddev  = 0;
  my $skew    = 0;
  my $kurt    = 0;
  my $kurtex  = 0;
  my $min     = $list[0];
  my $max     = $min;
  my $spread  = 0;
  my $m2      = 0;
  my $m3      = 0;
  my $m4      = 0;
  my $pcnts_v = [];

  #=============== Get min/max if it's a histogram
  if ( $hist ) { 
    for ( my $i = 0; $i <= $#list; $i++ ) { 
      if ( $list[$i] ) { 
        $min = $i*$binwidth+$base; 
        last;
      }
    }
    for ( my $i = $#list; $i >= 0; $i-- ) { 
      if ( $list[$i] ) { 
        $max = $i*$binwidth+$base+$binwidth;
        last;
      }
    }
  } else { 
    $min = Min(\@list);
    $max = Max(\@list);
  }

  #print "MIN = $min   MAX = $max\n";
  #exit;



  #=============== Calculate the Mean
  for my $x (0..$#list) {
    my ($y, $t, $m);
    if ( $hist ) { 
      $y = $x*$binwidth+$base+$binwidth*0.5;
      $t = $list[$x] || 0;
      $m = $t > 0 ? $y : $max;
    } else {
      next if not defined $list[$x];
      $y = $list[$x];
      $t = 1;
      $m = $y;
    }
    $mean += $y*$t;
    #$max = $m if $m > $max;
    #$min = $m if $m < $min;
    $count += $t;
  }
  if ( $count == 0 ) { 
    confess "Utility::Calculate_Distribution_Statistics !! Got 0 data points.\n" . Dumper(\@list);
  }
  $mean /= $count;

  #=============== Calculate Statistical Moments
  # y is the value
  # t is the count of that value for weighting in histograms
  for my $x (0..$#list) {
    my ($y, $t);
    if ( $hist ) { 
      $y = $x*$binwidth+$base+$binwidth*0.5;
      $t = $list[$x] || 0;
    } else {
      next if not defined $list[$x];
      $y = $list[$x];
      $t = 1;
    }
    my $d = $y - $mean;
    $m2 += $t*($d**2);
    $m3 += $t*($d**3);
    $m4 += $t*($d**4);
    #printf "%10.2f %10.4f %10.2f %10.2f %10.2f\n", $y, $t, $d, $m2, $m3, $m4;
  }
  #printf "\n\n";
  $m2 /= $count;
  $m3 /= $count;
  $m4 /= $count;

  #===== Standard Deviation is the square root of the 2nd moment (the variance)
  $stddev = sqrt($m2);

  #===== Skewness is the 3rd moment divided by the StdDev Cubed
  $skew = ( $m2 ? $m3/($stddev**3) : 'INF' );

  #===== Kurtosis is the 4th moment divided by the StdDev 4thed
  $kurt   = ( $m2 ? $m4/($stddev**4)   : 'INF' );
  $kurtex = ( $m2 ? $m4/($stddev**4)-3 : 'INF' ); # excess kurtosis


  #=============== Median and Other Percentiles
  # Todo: Calculate percentiles for histograms
  if ( not $hist ) { 
    $pcnts_v = Median(\@list, $pcnts_i);
  }

  my $stats = {
      mean    => $mean,
      stddev  => $stddev,
      stderr  => $stddev/sqrt($count),
      skew    => $skew,
      kurt    => $kurt,
      kurtex  => $kurtex,
      min     => $min,
      max     => $max,
      spread  => $max - $min,
      m2      => $m2,
      m3      => $m3,
      m4      => $m4,
      count   => $count,
      pcnts_i => $pcnts_i,
      pcnts_v => $pcnts_v,
    };
  foreach my $i ( 0..$#$pcnts_i ) { 
    my $pi = $pcnts_i->[$i];
    my $pv = $pcnts_v->[$i];
    $stats->{sprintf "pcnt_%02.0f", $pi} = $pv;
  }

  return $stats;
};

################################################### ANGULAR DISTANCE
# Distance between two angles, possibly circular around 360 degrees.

sub Angular_Distance { 
  my $x = $_[0] % 360;
  my $y = $_[1] % 360;

  my $D = abs($x-$y);
  if ( $D <= 180 ) { return $D }
  return abs($D-360);
}

############################################### PYTHAGOREAN DISTANCE

sub Distance {
  my $x = $_[0];
  my $y = $_[1];

  if ( scalar @$x != scalar @$y ) { 
    confess "Utility::Distance: Vecors x and y are different lengths";
  }

  return sqrt ( Sum ( map { ($x->[$_] - $y->[$_]) ** 2 } 0..$#$x ) );
}








################################################################### FIND MODES
# We are looking for the modes within a histogram.  There may be
# more than one mode, in which case it is defined as the highest
# point within $width units.  If two points are equally high within
# $width, the first is used.  If the histogram is $circular, the 
# code acts as though the first and last bins were adjacent.
# 
# Options
#   circular    | cicular histogram, as in a dihedral angle poupulation
#   window      | 
#   binwidth    | width of each histogram bin
#   length      | number of bins in the histogram 
#   start       | look for modes between start and stop value
#   stop        |
#   modemin     | minimum cutoff to be a mode (filters noise)
#   base        | value of minimum bin of histogram
#-----------------------------------------------------------------------------

sub Find_Modes {

  my $hist = $_[0];
  my $parm = $_[1];

  my $circular = exists $parm->{'circular'} ? $parm->{'circular'} :  0;
  my $window   = exists $parm->{'window'  } ? $parm->{'window'  } : 30;
  my $binwidth = exists $parm->{'binwidth'} ? $parm->{'binwidth'} :  1;
  my $length   = exists $parm->{'length'  } ? $parm->{'length'  } : scalar @$hist;
  my $start    = exists $parm->{'start'   } ? $parm->{'start'   } :  0;
  my $stop     = exists $parm->{'stop'    } ? $parm->{'stop'    } : $length-1;
  my $modemin  = exists $parm->{'modemin' } ? $parm->{'modemin' } : undef;
  my $base     = exists $parm->{'base'    } ? $parm->{'base'    } :  0;
#  my $minwidth = exists $parm->{'minwidth'} ? $parm->{'minwidth'} :  0;
#  my $minarea  = exists $parm->{'minarea' } ? $parm->{'minarea' } :  0;

  if ( $window > @$hist ) { $window = @$hist - 1; }
  my $window_i = POSIX::floor($window / $binwidth);

  # Error checking 
  if ( $length < @$hist ) { confess "Find_Modes: Length ($length) must be >= the length of the array ( " . scalar @$hist . ")"; }
  if ( $stop < $start ) {  confess "Find_Modes: Start ($start) must be >= Stop ($stop)."; }

  my @modes = ();
  
  #===== Scan through the histogram
  foreach my $i ( $start..$stop ) {

    my $h = $hist->[$i] || 0;
    next if ( defined $modemin and $h < $modemin );

    #--- Test that the point is higher than all points within $window
    my $highest = 1;
    foreach my $j ( ($i-$window_i) .. ($i-1) , ($i+1) .. ($i+$window_i) ) {
      my $k;
      if ( $j < $start ) {
        if ( $circular ) { $k = $j % $length; } 
        else             { next; }
      } elsif ( $j > $stop ) { 
        if ( $circular ) { $k = $j % $length; }
        else             { next; }
      } else {
        $k = $j;
      }
      my $k_h = $hist->[$k] || 0;
      if ( $h <= $k_h ) { 
        if ( ($k > $i) and ($h == $k_h) ) { next; }
        #print "  defeated $i\n";
        $highest = 0;
        last;
      }
    }
    next if not $highest;
    #print "Found Mode $i $h\n";

    #--- Test that points to left and right do not 
    #    monotonically nondecrease up to some higher mode
    my $highest_left = 0;
    foreach my $j ( Range ( $i, $i - $length, -1 ) ) { 
      my $j_h = $hist->[$j % $length] || 0;
      if ( $j_h < $h ) { $highest_left = 1; last; }
      if ( $j_h > $h ) { last; } 
    }
    next if not $highest_left;

    my $highest_right = 0;
    foreach my $j ( Range ( $i, $i + $length, 1 ) ) { 
      my $j_h = $hist->[$j % $length] || 0;
      if ( $j_h < $h ) { $highest_right = 1; last; }
      if ( $j_h > $h ) { last; } 
    }
    next if not $highest_right;

    #--- Create new mode entry.
    push @modes, {
      mode    => $i*$binwidth + $base,
      mode_i  => $i,
      height  => $h,
    };
  }


  # Now that the modes are enumerated, find their properties
  my $max_mode_height;
  my $max_mode_area;
  foreach my $m ( 0..$#modes ) {

    my $mode = $modes[$m];
    my $mode_i = $mode->{'mode_i'};
    my $h = $mode->{'height'};

    # Find the left and right half width @ half heights
    my ($lhw_i, $lhh, $rhw_i, $rhh, $lmin_i, $lmin_h, $rmin_i, $rmin_h);
    
    # Left
    my $left_wall = 0;
    if ( $m > 0 ) { $left_wall = $modes[$m-1]{'mode_i'}; }
    else { 
      if ( $circular ) { $left_wall = - ($length - $modes[-1]{'mode_i'} ) }
      else             { $left_wall = $start; } 
    }

    $lmin_i = $mode_i;
    $lmin_h = $h;
    for ( my $j = $mode_i; $j >= $left_wall; $j-- ) {
      my $k = $j % $length;
      my $j_h = $hist->[$k] || 0;

      # find left half width
      if ( (not defined $lhw_i) and ($j_h <= $h/2) ) {
        $lhw_i = $j;
        $lhh = $j_h;
      }
      # fine minimum until next mode, if lhw > lhh
      if ( $j_h < $lmin_h ) { 
        $lmin_i = $j;
        $lmin_h = $j_h;
      }
    }

    if ( not defined $lhw_i ) { 
      $lhw_i = $lmin_i;
      $lhh = $lmin_h;
    }

    # Right
    my $right_wall = 0;
    if ( $m < $#modes ) { $right_wall = $modes[$m+1]{'mode_i'}; }
    else { 
      if ( $circular ) { $right_wall = $modes[0]{'mode_i'} + $length; }
      else             { $right_wall = $stop; } 
    }

    $rmin_i = $mode_i;
    $rmin_h = $h;
    for ( my $j = $mode_i; $j <= $right_wall; $j++ ) {
      my $k = $j % $length;
      my $j_h = $hist->[$k] || 0;
      # find left half width
      if ( (not defined $rhw_i) and ($j_h <= $h/2) ) {
        $rhw_i = $j;
        $rhh = $j_h;
      }
      # fine minimum until next mode, if lhw > lhh
      if ( $j_h < $rmin_h ) { 
        $rmin_i = $j;
        $rmin_h = $j_h;
      }
    }

    if ( not defined $rhw_i ) { 
      $rhw_i = $rmin_i;
      $rhh = $rmin_h;
    }

    #if ( $rhw_i == $mode_i ) { confess "CRAP $mode_i $right_wall" . Dumper ($hist) }

    #print "$i\t$h\t$lhw\t$lhh\t$rhw\t$rhh\n";
    # Calculate geometry of this mode.
    my $lhw  = $lhw_i * $binwidth + $base;
    my $rhw  = $rhw_i * $binwidth + $base;
    my $lmin = $lmin_i * $binwidth + $base;
    my $rmin = $rmin_i * $binwidth + $base;
    my $hw   = ($rhw-$lhw+$binwidth)/2;
    my $kurt_rat = $h / ($hw * 2);
    my $skew_rat = ($mode_i-$lhw_i)/($rhw_i-$mode_i);

    my $halfarea = 0;
    for my $j ( $lhw_i..$rhw_i ) { $halfarea += $hist->[$j % $length] || 0 }
    my $width = $rmin - $lmin + $binwidth;
    my $area = 0;
    for my $j ( $lmin_i..$rmin_i ) { $area += $hist->[$j % $length] || 0 }

    # Pump them into the mode.
    $mode->{'lhw'   } = $lhw;
    $mode->{'lhw_i' } = $lhw_i;
    $mode->{'lhw_d' } = $m-$lhw;
    $mode->{'lhh'   } = $lhh;
    $mode->{'lmin'  } = $lmin;
    $mode->{'lmin_i'} = $lmin_i;
    $mode->{'lmin_h'} = $lmin_h;
    $mode->{'lw'    } = $left_wall;

    $mode->{'rhw'   } = $rhw;
    $mode->{'rhw_i' } = $rhw_i;
    $mode->{'rhw_d' } = $rhw-$mode_i;
    $mode->{'rhh'   } = $rhh;
    $mode->{'rmin'  } = $rmin;
    $mode->{'rmin_i'} = $rmin_i;
    $mode->{'rmin_h'} = $rmin_h;
    $mode->{'rw'    } = $right_wall;

    $mode->{'half_width' } = $hw;
    $mode->{'half_area'  } = $halfarea;
    $mode->{'width'      } = $width;
    $mode->{'area'       } = $area;
    $mode->{'kurt_rat'   } = $kurt_rat;
    $mode->{'skew_rat'   } = $skew_rat;
 

    my $stats = Calculate_Distribution_Statistics ( 
      [map { $hist->[$_ % $length] || 0 } ($lmin_i..$rmin_i)],
      { hist=>1, binwidth=>$binwidth, base=>$lmin }
    ); 
    map { $mode->{$_} = $stats->{$_} } keys %$stats;

    my $stats_window = Calculate_Distribution_Statistics ( 
      [map { $hist->[$_ % $length] || 0 } ($mode_i-$window_i)..($mode_i+$window_i)],
      { hist=>1, binwidth=>$binwidth, base=>(($mode_i-$window_i)*$binwidth+$base) }
    );
    my $w_area = Sum([map { $hist->[$_%$length] || 0 } ($mode_i-$window_i)..($mode_i+$window_i)]);
    map { $mode->{"window_$_"} = $stats_window->{$_} } keys %$stats_window;
    $mode->{"window_width"} = $window*2+$binwidth;
    $mode->{"window_area"} = $w_area;
    $mode->{'max_height'} = '-';
    $mode->{'max_area'} = '-';

    
    # Find maximal mode by area or by height
    if ( not defined $max_mode_height ) {
      $max_mode_height = $mode;
      $max_mode_area   = $mode;
    } else {
      if ( $max_mode_height->{'height'} < $mode->{'height'} ) { $max_mode_height = $mode; }
      if ( $max_mode_area  ->{'area'  } < $mode->{'area'  } ) { $max_mode_area   = $mode; }
  }
  }

  $max_mode_height->{'max_height'} = "MAX_HEIGHT";
  $max_mode_area  ->{'max_area'  } = "MAX_AREA";

  if ( wantarray ) { return @modes; }
  else             { return \@modes; }
}




##############################################################################
#                                                            STRING OPERATIONS
##############################################################################

sub Clean_Line {
  my $line = $_[0];
  return if not defined $line;
  chomp $line;
  $line =~ s/#.*$//;
  $line =~ s/\s*$//g;
  return $line;
}

sub Clean_Filename {
  my $file = $_[0];
  $file = Trim($file);
  $file =~ s/ /_/g;
  $file =~ s/\//_/g;
  $file =~ s/\\/_/g;
  $file =~ s/\*/all/g;
  return $file;
}

sub Trim {
  my $line = $_[0];
  $line =~ s/^\s+//g;
  $line =~ s/\s+$//g;
  return $line;
}



######### Populate Paths
sub Populate_Paths {
  my $CFG   = $_[0];
  my $dir   = Cwd::abs_path($_[1]);
  my $files = $_[2];
  if ( not ref $files eq 'HASH' ) { 
    confess "Utility::Populate_Paths !! Must be passed a config hash, a directory, and a hash of TITLE => FILENAME.\n";
  }

  if ( not -d $dir ) { 
    confess "Utility::Populate_Paths !! Was not passed a directory, '$dir'";
  }

  foreach my $title ( keys %$files ) { 
    my $file = $files->{$title};
    $CFG->{FILES}{$title} = $file;
    $CFG->{DIRS }{$title} = $dir;
    $CFG->{PATHS}{$title} = "$dir/$file";
  }
}


############################################# ADD PATH TO CONFIGURATION OBJECT
# Path is split into components, and components and some metadata is added
# in a standard format to a configuration hash.
sub Add_Path_to_Config { 
  my $CFG       = $_[0];
  my $name      = $_[1];
  my $new_path  = $_[2];
  my ( $path, $dir, $file ) = Utility::Split_Path($new_path);
  $CFG->{PATHS}{$name} = $path;
  $CFG->{DIRS }{$name} = $dir ;
  $CFG->{FILES}{$name} = $file;
  if ( -e $path ) { 
    $CFG->{DATES}{$name} = (-M $path) * 24 * 60 * 60 + $START_TIME;
    if ( -f $path ) { 
      $CFG->{SIZES}{$name} = -s $path;
    }
  }
}


######### Split Path
# Splits relative or absolute path into (absolute path, directory, file)

sub Split_Path {

  my $path          = $_[0];
  my $default_file  = $_[1];

  my @default_files = ();
  if ( defined $default_file ) { 
    if ( ref $default_file eq 'ARRAY' ) { 
      @default_files = @$default_file;
    } else { 
      @default_files = ($default_file);
    }
  }

  if ( not defined $path ) { 
    confess "Utility::Split_Path !! Passed undefined path\n";
  }


  $path =~ s/\/\//\//g; #Convert double slashes to singles
  my $file = '';
  my $dir  = '';
  my $volume = '';

  if ( not $path ) { 
    #warn "Utility::Split_Path Did not pass a path\n"; 
    return;
  }

  # Parse a virtual path without testing for existence.
  if ( not -e $path and not -l $path ) { 

    #----- Path is just a file, no /'s
    if ( $path !~ /\// ) { 
      $file = $path;
      $dir  = '';
    }

    #----- Split into dir and file
    elsif ( $path =~ /^(.*\/)([^\/]*?)$/ ) { 
      $dir  = $1 || '';
      $file = $2 || '';

    #----- WTF
    } else { 
      confess "Utility::Split_Path !! Couldn't parse path, '$path'";
    }

    # Prefix cwd to relative paths
    if ( not $path =~ /^\// ) { 
      my $cwd = getcwd();
      $dir = "$cwd/$dir";
    }
  
    my $fullpath = "$dir$file";

    #print "Split path came up with: \n"
    #    . "  orig: '$path'\n"
    #    . "  path: '$fullpath'\n"
    #    . "  dir:  '$dir'\n"
    #    . "  file: '$file'\n"
    #    ;
    return ( $fullpath, $dir, $file );
  }

  $path = File::Spec->rel2abs($path);

  if ( -d $path ) { 
    $path = Cwd::abs_path($path);
    $dir = $path;
    foreach my $default_file ( @default_files ) { 
      if ( -e "$dir/$file" ) { 
        $file = $default_file;
        last;
      }
    }
  } else { 
    ($volume, $dir, $file) = File::Spec->splitpath($path);
  }

  #} elsif ( $path =~ /^(.*)\/([^\/]+)$/ ) {
  #  $dir = $1;
  #  $file = $2;
  #} else { 
  #  $dir = getcwd();
  #  $file = $path;
  #}

  my $fullpath = "$dir$file";
  return ($fullpath, $dir, $file);
}


sub Make_Directories {
  my $dir = $_[0];
  
  my @dirs = split /\//, $dir;

  my $d = (( substr $dir, 0, 1) eq '/' ? '/' : '' );
  foreach my $subdir ( @dirs ) {
    next if not defined $subdir or $subdir =~ /^\s*$/;
    $d .= "$subdir/";
    for ( 1..10 ) {
      if ( not -e ( $d ) ) {
        mkdir $d;
        if ( -e $d ) { last }
        sleep(1);
      }
    } 
    if ( not -e $d ) {
      confess "Couldn't mkdir '$d'. $!";
    } elsif ( not -d $d ) {
      print "Trying to mkdir '$d', but it already exists as a normal file.\n";
    }
  }
}




##############################################################################
#                                                            RANGE SUBROUTINES
#-----------------------------------------------------------------------------
# Convenience functions to turn numerical or alphabetical ranges into specific
# numbers or characters, for use when parsing command line or configuration 
# file arguments. Positive or negative, capital or small case.
#
# A range is a set of range groups (separated by spaces or semicolons).  
# A range group is a set of intervals separated by commas.
# An interval can be a single point or a X-Y range, inclusive of both X and Y.
#   intervals will be processed as X..Y in perl, so must follow those rules.
# 
# Range groups can be excluded by prefixing the group with !.  This is the 
# only distinction between separating by comma vs. semicolon/space, the 
# ! exclusion only applies until the next space.
# 
# Ranges are processed in order, so if inclusion/exclusion is mixed, 
# latter ranges take precedence (assuming the standard subroutines are used).
#
# Range should be specified as a comma separated list where
# each item may be an individual number (non-negative) or a 
# number hyphen number style subrange.  Spaces are optional at
# at any point, as they will be removed when parsing.
# 
# Range groups can be excluded by prefixing them with !.  A ! appearing 
# anywhere else is a parse error.
#
# Examples:
#   1,2 3 5-9     : 1,2,3,5,6,7,8,9
#   1-10;!4-6;5   : 1 through 10 except for 4,6 (so yes 5)
#   -10--5        : -10 through -5
#   a-q,3-6       : Parse Error
##############################################################################



######################################################################## RANGE
# A range operator with an increment size argument.
# Positive or negative increments allowed.
# If passed an array reference, instead generates a 0..$#array index list

sub Range {
  my $start = $_[0];
  my $end   = $_[1];
  my $incr  = $_[2] || 1;
  my $incl  = $_[3] || 0; # inclusive of last value

  # Process an array index list instead of an interval
  if ( ref $start eq 'ARRAY' ) { 
    my $range = [0..$#$start];
    if ( wantarray ) { return  @$range }
    else             { return   $range }
  }

  # Convenience syntax to return integers from 0 to a number
  if ( not defined $end ) {
    $end = $start;
    $start = 0;
  }
 
  # Generate the array using positive or negative increment.
  my @array = ();
  my $x;
  if ( $incl ) { 
    if ( $incr > 0 ) { for ( $x=$start; $x <= $end; $x+=$incr ) { push @array, $x } }
    if ( $incr < 0 ) { for ( $x=$start; $x >= $end; $x+=$incr ) { push @array, $x } }
  } else { 
    if ( $incr > 0 ) { for ( $x=$start; $x <  $end; $x+=$incr ) { push @array, $x } }
    if ( $incr < 0 ) { for ( $x=$start; $x >  $end; $x+=$incr ) { push @array, $x } }
  }
  if ( wantarray ) { return @array }
  else             { return \@array }
}


################################################################## PARSE RANGE
# Simple splitting of a range string by space or commas, expansion of 
# dashed ranges, and then sorting/uniquifying of the individual points.

sub Parse_Range { 
  my @ranges = @_;

  my @points = ();
  foreach my $range (@ranges) { 
    $range =~ s/!//g;
    my @sub = split /\s+|,|\+/, $range;
    foreach my $s (@sub) { 
      if ( $s =~ /^(\d+)-(\d+)$/ ) { 
        push @points, $1..$2;
      } elsif ( $s =~ /^([a-z])-([a-z])$/i ) { 
        push @points, $1..$2;
      } elsif ( $s =~ /^\d+$/ ) { 
        push @points, $s;
      } elsif ( $s =~ /^\w+$/i ) { 
        push @points, $s;
      } else {
        confess "Unknown range syntaxt '$s' in '$range'.\n";
      }
    }
  }

  return if scalar @points == 0;
  @points = Utility::Unique ( @points );
  if ( Is_Number($points[0]) ) { @points = sort {$a <=> $b} @points }
  else                         { @points = sort {$a cmp $b} @points } 

  if ( wantarray ) { return  @points }
  else             { return \@points }

}



######################################################### MAKE CONTIGUOUS LIST
# The inverse of Parse_Range, basically.  Take a list, sort it, and 
# convert it to a human-readable set of intervals.
sub Make_Contiguous_Lists { 
  my @vals = sort { $a <=> $b } @_;
  my @list = ();
  
  for ( my $i = 0; $i <= $#vals; $i++ ) { 
    for ( my $j = $i; $j <= $#vals; $j++ ) { 

      my $end = 0;
      if    ( $j == $#vals ) { $end = 1; }
      elsif ( $vals[$j] != ($vals[$j+1]-1) ) { $end = 1; }
      else { next }

      if ( $i < $j ) { push @list, "$vals[$i]-$vals[$j]" }
      else           { push @list, "$vals[$i]"    }
      $i=$j;
      last;
  
    }
  }
  return @list;
}





################################################################ PROCESS RANGE
# Creates a Range object for use with subsequent subroutines.  The former
# version of this subroutine (for use in the rotamer library) has been moved
# to Rotamer.pm
# TODO: Convert to new RANGE object.
# TODO: Allow min/max arguments, or actual passing of datapoints, so that
#       a real range can be generated instead of querying at each iteration.
# TODO: As in Parse_Residue_Range, allow for aliases 
sub Process_Range { 

  my @ranges = @_;

  my %RANGE = (
    include     => [],
    exclude     => [],
    points      => [],
    include_all => 0,
    exclude_all => 0,
  );
  confess "Process_Range not implimented yet.\n";
}

sub Parse_Residue_Range { 

  my $range = $_[0];
  my $regions = $_[1];

  my %regions;
  if ( ref $regions eq 'HASH' ) { 
    %regions = %$regions;
  }

  my @range = split ",", $range;
  my @range_str = ();

  foreach my $ran ( @range ) { 
    my $did_sub = 0;
    foreach my $r ( keys %regions ) { 
      if ( $r eq $ran ) { 
        my $str = $regions{$ran}{'str'};
        #print "Subbing $r $str for $range\n";
        push @range_str, $str;
        $did_sub = 1;
        last;
      }
    }
    
    if ( $ran =~ /^\d+$/ or $ran =~ /^\d+-\d+$/ ) { 
      push @range_str, $ran;
      next;
    }

    if ( not $did_sub and $ran =~ /([a-z]+)/ ) { 
      die "Unknown region '$ran' in residue range $range";
    }
  }
  return Utility::Parse_Range ( join ',', @range_str );
}



################################################################### PAST RANGE
# Test if a point is past the end of a range while iterating.
# TODO: Convert to new RANGE object.
# TODO: keep a max_point value somewhere so we can tell if exclude goes to the end or not.
sub Past_Range {
  my $RANGE = $_[0];
  my $point = $_[1];

  # Default Included, Process Excluded Ranges
  if ( $RANGE->{include_all}   ) { return 0 } # All points included
  if ( $RANGE->{exclude_all}   ) { return 1 } # All points excluded
  if ( $point > $RANGE->{last} ) { return 1 } # Less than last point
  else                           { return 0 } # Past the end
}
  
##################################################################### IN RANGE
# Test all intervals of a RANGE object to see if the point is in range.
# TODO: Convert to new RANGE object.
sub In_Range {
  my $intervals = $_[0];
  my $point     = $_[1];

  # Points have highest priority.
  foreach ( @{$intervals->{'points'}} ) {
    if ( $point == $_ ) { return 1 };
  }

  # Default Included, Process Excluded Ranges
  if ( $intervals->{'include_all'} ) {
    foreach ( @{$intervals->{'exclude'}} ) {
      if ( $_->[0] <= $point and $_->[1] >= $point ) { return 0; }
    } 
    return 1;
  }

  # Default Exclude, Process Included Ranges
  else {
    foreach ( @{$intervals->{'include'}} ) {
      if ( $_->[0] <= $point and $_->[1] >= $point ) { return 1; }
    } 
    return 0;
  }
}


############################################################# INTERVAL SAMPLES
# Extract sample points from the RANGE given an increment.
# TODO: Convert to new RANGE object.

sub Interval_Samples {
  my $intervals = $_[0];
  my $incr      = $_[1];
  my $min       = $_[2] || 0;
  my $max       = $_[3] || 100000;

  my @array = ();
  foreach (@{$intervals->{'points'}} ) { push @array, $_; }

  my $point;
  if ( $intervals->{'include_all'} ) {
      push @array, grep { $point = $_;
                          not map { $point <= $_->[0] and $point >= $_->[1] } 
                                  @{$intervals->{'exclude'}} } 
                        ( Range ( $min, $max, $incr ) );
  }

  foreach ( @{$intervals->{'include'}} ) {
    push @array, Range ( $_->[0], $_->[1], $incr );
  }

  if ( not @array ) {
    if ( $intervals->{'include_all'} ) {
      confess "Crap, Unimplemented. $!";
    } else {
      foreach (@{$intervals->{'include'}}) { 
        push @array, $_->[0]..$_->[1];
      }
    }
  }
  return @array;
}



##############################################################################
##############################################################################
##############################################################################
#                                    MATH
##############################################################################
##############################################################################
##############################################################################



##############################################################################
#                                                             MATH SUBROUTINES
##############################################################################


################################ CONVERT STRING TO A NUMBER USING POSIX STRTOD
sub Get_Number {
    use POSIX qw(strtod);
    my $str = shift;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//;
    $! = 0;
    my($num, $unparsed) = strtod($str);
    if (($str eq '') || ($unparsed != 0) || $!) {
        return;
    } else {
        return $num;
    } 
} 

############################################### GET HIGHEST LOG SMALLER THAN X
sub Get_Log_Under { 
  my $base  = $_[0];
  my $value = $_[1];
  if ( not $value ) { confess "Utility::Get_Log_Under !! Cannot take a log of 0" }
  return POSIX::floor(log($value) / log($base));
}

################################################# GET LOWEST LOG LARGER THAN X
sub Get_Log_Over { 
  my $base  = $_[0];
  my $value = $_[1];
  if ( not $value ) { confess "Utility::Get_Log_Over !! Cannot take a log of 0" }
  return POSIX::ceil(log($value) / log($base));
}

############################################ GET LOG VALUES CONTAINING A RANGE
sub Get_Log_Range { 
  my $base = $_[0];
  my $min = $_[1];
  my $max = $_[2];
  return ( Get_Log_Under($base, $min), Get_Log_Over($base, $max) );
}

############################################################## IS NUMBER (ETC)
sub Is_Number { 
  my $num = $_[0];
  my $num_t = Get_Number($num);
  my $is = defined scalar $num_t; 
  return $is;
} 

sub Is_Integer          { return $_[0] =~ /^-?\d+$/ }
sub Is_Positive_Integer { return $_[0] =~ /^\d+$/ }
sub Is_Negative_Integer { return $_[0] =~ /^-\d+$/ }

########################################################## DETERMINE DATA TYPE
sub Determine_Data_Type { 

  my $data = $_[0];
  my @types = ();
  foreach my $i ( 0..$#$data ) { 
    my $datum = $data->[$i];
    if ( not defined $datum ) { 
      $types[$i] = 'UNDEF';
      next;
    }

    my $ref = ref $datum;
    if    ( $ref eq 'ARRAY'   ) { $types[$i] = 'ARRAY'     } 
    elsif ( $ref eq 'HASH'    ) { $types[$i] = 'HASH'      }
    elsif ( $ref eq 'SCALAR'  ) { $types[$i] = 'SCALAR'    } 
    elsif ( Is_Integer($datum)) { $types[$i] = 'INTEGER'   }
    elsif ( Is_Number($datum) ) { $types[$i] = 'FLOAT'     }
    elsif ( $datum eq ''      ) { $types[$i] = 'EMPTY'     }
    else                        { $types[$i] = 'STRING'    } 
  }

  return ( wantarray ? @types : \@types );

}

################################################ DETERMINE UNIVERSAL DATA TYPE
# Get broadest data type that allows all the subdatatypes
# TODO: Support more than integer, float, and string.

sub Determine_Universal_Data_Type { 

  my $data  = $_[0];
  my $types = Determin_Data_Type($data);

  my $universal;

  foreach my $type ( @$types ) { 
   
    # Type isn't defined, so ignore
    if ( $type eq 'EMPTY' 
      or $type eq 'UNDEF' ) { 
      next;
    }
   
    
    # First defined type
    if ( not defined $universal
      or $universal eq 'EMPTY'
      or $universal eq 'UNDEF' ) { 
      $universal = $type;
      next;
    }

    # Strings are the broadest category, so no need to test anything else
    if ( $type eq 'STRING' ) { 
      $universal = 'STRING';
      last;
    }
  
    # Floats replace ints or undefined types
    if ( $type eq 'FLOAT' ) {
      if ( $universal eq 'INTEGER' ) { 
        $universal = $type;
        next;
      }
    }

    # Integers don't replace anything
    if ( $type eq 'INTEGER' ) { 
      next;
    }

    die "Don't know what to do with type $type";
  }

  return $universal;

}


############################################################## COMMAFY INTEGER
# Make large integers more human readable by adding commas. 
# TODO: Harder than it looks.  This hacky-ass version of it needs some work.
#
sub Commafy_Integer { 
  my $x = reverse sprintf "%.0f", $_[0];
  $x =~ s/(\d\d\d)(\d)/$1,$2/g;
  $x =~ s/(\d\d\d)(\d)/$1,$2/g;
  $x =~ s/(\d\d\d)(\d)/$1,$2/g;
  $x =~ s/(\d\d\d)(\d)/$1,$2/g;
  $x =~ s/(\d\d\d)(\d)/$1,$2/g;
  $x =~ s/(\d\d\d)(\d)/$1,$2/g;
  $x =~ s/(\d\d\d)(\d)/$1,$2/g;
  return scalar reverse $x;
}





##############################################################################
#                                                            VECTOR OPERATIONS
##############################################################################

sub Vector_to_String { 
  my @v = ();
  if ( ref $_[0] eq 'ARRAY' ) { @v = @{$_[0]} }
  else                        { @v = @_ }
  return sprintf "%6.2f, %6.2f, %6.2f", @v;
}

sub Vector_From_Points { 
  my $m = $_[0];
  my $n = $_[1];
  my @x = map { $n->[$_] - $m->[$_] } 0..$#$m;
  if ( wantarray ) { return  @x }
  else             { return \@x }
}

sub Vector_Minus { 
  my $x = $_[0];
  my $y = $_[1];
  my @z = map { $x->[$_] - $y->[$_] } 0..$#$x;
  if ( wantarray ) { return  @z }
  else             { return \@z }
}

sub Vector_Scale {
  my $x = $_[0];
  my $s = $_[1];
  my @z = map { $x->[$_] * $s } 0..$#$x;
  if ( wantarray ) { return  @z } 
  else             { return \@z }
}

sub Vector_Dot {
  my $x = $_[0];
  my $y = $_[1];
  my $dot = Sum(map { $x->[$_] * $y->[$_] } 0..$#$x);
  return $dot;
}

sub Vector_Cross { 
  my $x = $_[0];
  my $y = $_[1];
  confess "Can only cross vectors of dimension 3." if $#$x != 2;
  my @z = ();
  $z[0] = $x->[1]*$y->[2] - $x->[2]*$y->[1];
  $z[1] = $x->[2]*$y->[0] - $x->[0]*$y->[2];
  $z[2] = $x->[0]*$y->[1] - $x->[1]*$y->[0];
  if ( wantarray ) { return  @z } 
  else             { return \@z }
}

sub Vector_Magnitude {
  my $x = $_[0];
  my $z;
  for my $i ( 0..$#$x ) { $z += $x->[$i] * $x->[$i] }
  return sqrt(abs($z));
}

sub Vector_Angle { 
  my $x = $_[0];
  my $y = $_[1];
  return 
    acos ( 
      Vector_Dot ( $x, $y ) / 
        ( Vector_Magnitude ( $x ) * Vector_Magnitude ( $y ) ) );
}

sub Vector_to_Unit { 
  my @x;
  if ( ref $_[0] eq 'ARRAY' ) { @x = @{$_[0]} }
  else                        { @x = @_ }
  my $m = Vector_Magnitude(\@x);
  my $y = Vector_Scale(\@x, 1/$m);
  my $n = Vector_Magnitude($y);
  return $y;
}


# Math from Wikipedia: http://en.wikipedia.org/wiki/Dihedral_angle
# gamma = atan2( |b2| * b1 . [b2 x b3], [b1 x b2] . [b2 x b3])
# Where: The dihedral angle is between points A, B, C, D
#   and  b1 = B-A, b2 = C-B, b3 = D-C
#
# Actually, this ended up being helpful too:
#   http://math.stackexchange.com/questions/47059/how-do-i-calculate-a-dihedral-angle-given-cartesian-coordinates
#

sub Dihedral_Angle { 
  my @p = @_;

  #print "Dihedral Angle Points: " . Dumper(\@points) . "\n";

  foreach my $i ( 0..3 ) { 
    my $p = $p[$i];
    if ( not defined $p ) { confess "Point $i not defined.\n"; }
    if ( not ref $p eq 'ARRAY' ) { confess "Point $i ('$p') is not an array reference."; }
    if ( not scalar @$p == 3 ) { confess "Point $i ('$p'} is not a 3D point."; }
  } 

  my $b1 = Vector_From_Points($p[0], $p[1]);
  my $b2 = Vector_From_Points($p[2], $p[1]); # Reversed to correct for sign.
  my $b3 = Vector_From_Points($p[2], $p[3]);
  
  my $n1 = Vector_to_Unit(Vector_Cross($b1, $b2));
  my $n2 = Vector_to_Unit(Vector_Cross($b2, $b3));
  my $m1 = Vector_Cross($n1, Vector_to_Unit($b2));
  
  my $x = Vector_Dot($n1, $n2);
  my $y = Vector_Dot($m1, $n2); 

  my $rad = atan2 ($y, $x);
  my $deg = rad2deg($rad);
  
  return $deg;
}







#################################################################### Chirality

sub Get_Chirality { 
  my $w = $_[0];
  my $x = $_[1];
  my $y = $_[2];
  my $z = $_[3];

  my $matrix = [ [ 1, @$w ],
                 [ 1, @$x ],
                 [ 1, @$y ],
                 [ 1, @$z ] ];

  my $det = Matrix_Determinant ( $matrix );
  return $det;
}


sub Chirality { 
  my $w = $_[0];
  my $x = $_[1];
  my $y = $_[2];
  my $z = $_[3];

  my $matrix = [ [ 1, @$w ],
                 [ 1, @$x ],
                 [ 1, @$y ],
                 [ 1, @$z ] ];

  my $det = Matrix_Determinant ( $matrix );

  if ( $det > 0 ) { return 'l' }
  if ( $det < 0 ) { return 'r' }
  return '';
}


###############################################################################
#                                                             MATRIX OPERATIONS
###############################################################################


############################################################# MATRIX DIMENSIONS
# X and Y dimensions of a 2D matrix
sub Matrix_Dimensions { 
  my $matrix = $_[0];
  my $dim_x = scalar @$matrix;
  return 1 if not $dim_x;
  my $dim_y = scalar @{$matrix->[0]};
  for my $i ( 1..$dim_x-1 ) { 
    if ( $dim_y != scalar @{$matrix->[$i]} ) { 
      confess "Matrix rows must all be the same length to take a determinant.";
    }
  }
  return $dim_x, $dim_y;
}


################################################################# MATRIX REDUCE
# 
sub Matrix_Reduce { 
  my $matrix = $_[0];
  my ($dim_x, $dim_y) = Matrix_Dimensions ( $matrix );

  my $i = 0;
  my $j = 0;

  my $det = 1;

  while ( $i < $dim_x and $j < $dim_y ) { 

    # Find pivot row max_i of column j
    my $max_i = $i;
    for my $k ( $i+1 .. $dim_x-1 ) { 
      if ( abs($matrix->[$k][$j]) > abs($matrix->[$max_i][$j]) ) { 
        $max_i = $k;
      }
    }

    # If column is not 0
    if ( $matrix->[$max_i][$j] != 0 ) { 
      # Swap rows
      if ( $i != $max_i ) { 
        #print "Swapping rows $i and $max_i\n";
        $det *= -1;
        my $temp = $matrix->[$max_i];
        $matrix->[$max_i] = $matrix->[$i    ];
        $matrix->[$i    ] = $temp;
      }

      # Reduce row
      my $x = $matrix->[$i][$j]; 
      for my $l ( $j..$dim_y-1 ) { $matrix->[$i][$l] /= $x }
      $det /= $x;

      # Zero out subsequent rows in the column
      for my $k ( $i+1 .. $dim_x-1 ) { 
        my $x = $matrix->[$k][$j];
        for my $l ( $j .. $dim_y-1 ) { 
          $matrix->[$k][$l] -= $matrix->[$i][$l] * $x;
        }
      }
      $i++;
    }
    $j++;
  }
  return $det;
}



############################################################ MATRIX DETERMINANT
sub Matrix_Determinant { 

  my $matrix = $_[0];
  my ($dim_x, $dim_y) = Matrix_Dimensions ( $matrix );
  if ( $dim_y != $dim_x ) { 
    confess "Matrix must be square to take a determinant.";
  }


  my $det = Matrix_Reduce ( $matrix );
  #confess Dumper ($matrix);
  foreach my $i ( 0..$dim_x-1 ) { $det *= $matrix->[$i][$i] }
  return $det;

}

##################################################################### TRANSPOSE
sub Transpose { 

  my $matrix = $_[0];

  my @new = ();
  foreach my $i ( 0..$#$matrix ) { 
    my $row = $matrix->[$i];
    foreach my $j ( 0..$#$row ) { 
      $new[$j][$i] = $matrix->[$i][$j];
    }
  }

  if ( wantarray ) { return  @new }
  else             { return \@new } 

}
####################################################################### FLATTEN
# Recursively traverse a multi-dimensional array and extract all the
# values into a vector.
#
sub Flatten { 
  my @matrix = grep { defined $_ } @_;

  #===== Empty
  return if not scalar @matrix;

  #===== Already Flat
  if ( ref $matrix[0] eq '' ) { return @_ }

  #===== Nested Arrays
  if ( ref $matrix[0] eq 'ARRAY' ) { 
    return ( map { Flatten(@$_) } @matrix );
  }

  #===== Nested Hashes
  if ( ref $matrix[0] eq 'HASH' ) { 
    return ( map { Flatten(values %$_) } @matrix );
  }

  croak "Utility::Flatten: Parameters must be numbers or a reference to a matrix of numbers. Not sure how I got here.\n"
      . Dumper(@matrix)
      ;

}



################################################### TEXT CONVERSIONS


sub Human_Readable_Size {
  my $size = $_[0];
  my $size_text;
  if    ( $size > 1024*1024*1024 ) { $size_text = sprintf "%5.2f GB", $size/1024/1024/1024; }
  elsif ( $size > 1024*1024      ) { $size_text = sprintf "%5.2f MB", $size/1024/1024       }
  elsif ( $size > 1024           ) { $size_text = sprintf "%5.2f KB", $size/1024            }
  else                             { $size_text = sprintf "%5i  B",   $size                 }
  return $size_text;
}

sub Human_Readable_Condensed_Date {

  my $time = $_[0];

  my $timestr = POSIX::strftime "%y/%m/%d %H:%M:%S", localtime($time);
  return $timestr

}

sub Human_Readable_Time {
  my $time = $_[0];
  my $min  = $_[1] || 's';
  my $explicit = $_[2] || 0; # adds d m h s to timestamps.
  my $string = "";
  my $seconds = 1;
  my $minutes = 60 * $seconds;
  my $hours   = 60 * $minutes;
  my $days    = 24 * $hours;

  my $d = POSIX::floor($time / $days);  $time %= $days;
  my $h = POSIX::floor($time / $hours ); $time %= $hours;
  my $m = POSIX::floor($time / $minutes); $time %= $minutes;
  my $s = $time;
  
  my %convert = ( d=>4, h=>3, m=>2, s=>1 );
  my $min_time = $convert{$min};

  my ( $d_txt, $h_txt, $m_txt, $s_txt );
  if ( $explicit ) { ( $d_txt, $h_txt, $m_txt, $s_txt ) = ( 'd', 'h', 'm', 's' ) }
  else             { ( $d_txt, $h_txt, $m_txt, $s_txt ) = ( '',  '',  '',  ''  ) }

  my @string = ();
  if ( $d or $min_time >= 4 ) { push @string, sprintf "%02d%s", $d, $d_txt }
  if ( $h or $min_time >= 3 ) { push @string, sprintf "%02d%s", $h, $h_txt }
  if ( $m or $min_time >= 2 ) { push @string, sprintf "%02d%s", $m, $m_txt }
  if ( $s or $min_time >= 1 ) { push @string, sprintf "%02d%s", $s, $s_txt }

  return join ':', @string;

  $string = sprintf "%02d:%02d:%02d:%02d", $d, $h, $m, $s;
  #$string = sprintf "%dd%2dh%2dm%2ds", $d, $h, $m, $s;
  return $string;

  #if ( $time > $days ) { 
    $string .= sprintf "%4dd ", POSIX::floor ( $time / $days );
    $time %= $days;
  #}

  #if ( $time > $hours ) { 
    $string .= sprintf "%2dh ", POSIX::floor ( $time / $hours );
    $time %= $hours;
  #}

  #if ( $time > $minutes ) { 
    $string .= sprintf "%2dm ", POSIX::floor ( $time / $minutes );
    $time %= $minutes;
  #}
  
  $string .= sprintf "%2ds", $time;

   
  return $string;
}

############################################# TRACKING PROGRESS OF COMPUTATION

sub Rate_Initialize {

  my $steps = $_[0];
  my $flags = $_[1] || {};

  my @steps = ();
  if ( not (ref $steps eq 'ARRAY') ) { 
    @steps = 1..$steps;
  } else { 
    @steps = @$steps;
  }


  my $step_width = 80;
  foreach my $step ( @steps ) { 
    my $l = POSIX::floor((length $step) * 1.2);
    if ( $l > $step_width ) { $step_width = $l };
  }
 
  #my $step_width = 80; 
  if ( exists $flags->{'note'} ) {
    my $l = POSIX::floor((length $flags->{'note'}) * 1.2);
    if ( $l > $step_width ) { $step_width = $l };
  } 

  if ( exists $flags->{'notes'} ) { 
    foreach my $note ( @{$flags->{'notes'}} ) { 
      my $l = POSIX::floor((length $note) * 1.2);
      if ( $l > $step_width ) { $step_width = $l };
    }
  }

  my %cfg = (
    time_start    =>           time,
    time_now      =>           time,
    time_elapsed  =>              0,
    step_start    =>              0,
    step_now      =>              0,
    step_goal     =>  scalar @steps,
    step_elapsed  =>              0,
    step_time_min =>              0,
    elapsed_total =>              0,
    rate_step     =>              0,
    rate_total    =>              0,
    eta_step      =>              0,
    eta_total     =>              0,

    min_time      =>            's',
    explicit_time =>              1,
    
    steps         =>        \@steps,
    step_width    =>    $step_width,
    #note_width    =>    $note_width,
  );
  @cfg{keys %$flags} = values %$flags;
  return \%cfg;
}

sub Rate_Increment { 

  my $cfg = $_[0];
  my $steps = $_[1] || 1;

  $cfg->{'time_last'}     = $cfg->{'time_now'};
  $cfg->{'time_now'}      = time;
  
  $cfg->{'elapsed_total'} = $cfg->{'time_now'} - $cfg->{'time_start'};
  $cfg->{'elapsed_step' } = $cfg->{'time_now'} - $cfg->{'time_last' };

  $cfg->{'step_now'} += $steps;
  my $i = $cfg->{'step_now'}-1;
  $cfg->{'step_togo'}     = $cfg->{'step_goal'} - $cfg->{'step_now'};
  $cfg->{'step_name'}     = $cfg->{'steps'}[$i];
  if ( exists $cfg->{'note'} ) { 
    $cfg->{'step_note'} = $cfg->{'note'};
  }
  # Designed so note serves as a default but can be 
  # overridden by notes.
  if ( exists $cfg->{'notes'} ) { 
    if ( defined $cfg->{'notes'}[$i] ) { 
      $cfg->{'step_note'} = $cfg->{'notes'}[$i];
    }
  }

  # Will not recalculate rate if last step wasn't valid
  return if $cfg->{'elapsed_step'} < $cfg->{'step_time_min'};
  
  $cfg->{'step_real'}++;

  $cfg->{'rate_total'}    = $cfg->{'elapsed_total'} / $cfg->{'step_real'};
  $cfg->{'rate_step' }    = $cfg->{'elapsed_step'};

  $cfg->{'eta_total' }    = $cfg->{'rate_total'} * $cfg->{'step_togo'};
  $cfg->{'eta_step'  }    = $cfg->{'rate_step' } * $cfg->{'step_togo'};

}

sub Rate_Print { 
  my $cfg = $_[0];

  my $step_name = $cfg->{'step_name'};
  my $step_note = $cfg->{'step_note'};
  my $len_name  = length $step_name;
  my $len_line  = $cfg->{'step_width'};

  my $HASH_LINE = "#" x $len_line;
  my $DASH_LINE = "-" x $len_line;
  my $NAME_LINE = $HASH_LINE;
  my $mid_line  = POSIX::floor($len_line / 2.0);
  my $mid_name  = POSIX::floor($len_name / 2.0);
  substr $NAME_LINE, ($mid_line-$mid_name-1), $len_name+2, " $step_name ";

  my $NOTE_LINE = $DASH_LINE;
  if ( defined $step_note ) { 
    my $len_note  = length $step_note;
    my $mid_note  = POSIX::floor($len_note / 2.0);
    substr $NOTE_LINE, ($mid_line-$mid_note-1), $len_note+2, " $step_note ";
  }



  printf "$NAME_LINE\n"
       . "%d/%-d  |  Elapsed: %s  |  Time/Step: %s-%-s  |  ETA: %s-%-s\n"
       . "$NOTE_LINE\n"

       , $cfg->{'step_now'}
       , $cfg->{'step_goal'}
       #, $cfg->{'step_name'}
       , Human_Readable_Time($cfg->{ elapsed_total }, $cfg->{min_time}, $cfg->{explicit_time})
       , Human_Readable_Time($cfg->{ rate_step     }, $cfg->{min_time}, $cfg->{explicit_time})
       , Human_Readable_Time($cfg->{ rate_total    }, $cfg->{min_time}, $cfg->{explicit_time})
       , Human_Readable_Time($cfg->{ eta_step      }, $cfg->{min_time}, $cfg->{explicit_time})
       , Human_Readable_Time($cfg->{ eta_total     }, $cfg->{min_time}, $cfg->{explicit_time})
       ;

}


sub Rate_Update { 
  my $cfg = $_[0];
  my $steps = $_[1] || 1;
  Rate_Increment($cfg, $steps);
  Rate_Print ($cfg);
}





################################################################ OLD RATE CODE

sub Measure_Rate {

  my $time_start  = $_[0];
  my $time_now    = $_[1];
  my $at_start    = $_[2];
  my $at_now      = $_[3];
  my $at_goal     = $_[4];

  my $togo      = $at_goal  - $at_now;
  my $elapsed   = $time_now - $time_start;
  my $prog      = $at_now   - $at_start;
  my $rps       = $prog     / ($elapsed || 1);
  my $time_togo = $togo     / ($rps     || 1);
  my $eta_s     = Human_Readable_Time($time_togo);

  return {
    time_start  => $time_start,
    time_now    => $time_now,
    at_start    => $at_start,
    at_now      => $at_now,
    at_goal     => $at_goal,
    togo        => $togo,
    elapsed     => $elapsed,
    elapsed_s   => Human_Readable_Time($elapsed, 's'),
    elapsed_m   => Human_Readable_Time($elapsed, 'm'),
    elapsed_h   => Human_Readable_Time($elapsed, 'h'),
    elapsed_d   => Human_Readable_Time($elapsed, 'd'),
    prog        => $prog,
    rps         => $rps,
    rpm         => $rps * 60,
    rph         => $rps * 60 * 60,
    rpd         => $rps * 60 * 60 * 24,
    time_togo   => $time_togo,
    eta_s       => Human_Readable_Time($time_togo, 's'),
    eta_m       => Human_Readable_Time($time_togo, 'm'),
    eta_h       => Human_Readable_Time($time_togo, 'h'),
    eta_d       => Human_Readable_Time($time_togo, 'd'),

  };

}


################################################## PRINT RATES



sub Print_Double_Rate_Header { 
  my $title     = $_[0] || '';
  my $timestep  = $_[1] || 's';

  return 
    sprintf "%10s / %-10s %10s %9s - %-9s %9s - %-9s %s\n",
            "Current",
            "Goal",
            "Elapsed",
            "Imm_per_" . uc $timestep,
            "All_per_" . uc $timestep,
            "Togo_Imm",
            "Togo_All",
            "Title",
           ;
}


sub Print_Double_Rate_Line { 
  
  my $imm       = $_[0];
  my $all       = $_[1];
  my $title     = $_[2] || '';
  my $timestep  = $_[3] || 's';

  return 
    sprintf "%10u / %-10u %10s %9.2f - %-9.2f %9s - %-9s %s\n",
            $imm->{'at_now'},
            $imm->{'at_goal'},
            $all->{"elapsed_$timestep"},
            $imm->{"rp$timestep"},
            $all->{"rp$timestep"},
            $imm->{"eta_$timestep"},
            $all->{"eta_$timestep"},
            $title,
             ;
}


##############################################################################
#                       FILE I/O SUBROUTINES
#-----------------------------------------------------------------------------
##############################################################################


#################################################################### READ FILE
sub Read_File { 
  my $file = $_[0];
  my $fh = Open_File($file);
  my @contents = readline($fh);
  chomp @contents;
  close $fh or confess "Couldn't close file, '$file'. $!";

  if ( wantarray ) { return @contents }
  else             { return join "\n", @contents }
}


#################################################################### OPEN FILE
# Opens a file and return the open file handle.
# If the file is gzipped, selects the zcat library for unzipping.
# If the file isn't found, looks for a gzipped version to open 
#   i.e. looks for "$file.gz"
#-----------------------------------------------------------------------------
sub Open_File { 
  my $file    = $_[0];
  my $options = $_[1];
  my $FH;
  #warn "Open_File is opening file, '$file'\n";
  if ( not defined $file ) { 
    confess "Utility::Open_File !! No file passed.";
  }


  #=============== Write to File
  if ( $options->{write} ) { 
    if ( -e $file ) { 
      if ( not $options->{overwrite} ) { 
        confess "Won't open for writing without overwrite flag set, '$file'.";
      }
      open $FH, ">$file" or confess "Couldn't open file for writing, '$file'. $!";
      return $FH;
    }
  }

  #=============== Append File
  if ( $options->{append} ) { 
    open $FH, ">>$file" or confess "Couldn't open file for writing, '$file'. $!";
    return $FH;
  }

  #=============== Read File
  if ( -e $file ) { 
    if ( $file =~ /\.gz$/ ) {
      #warn "Opening file '$file' as zip file\n";
      open $FH, "zcat $file|" or confess "Couldn't open gzipped file, '$file'. $!";
    } else { 
      #warn "Openning file '$file' normally\n";
      open $FH, $file or confess "Couldn't open file, '$file'. $!";
    }
  } elsif ( -e "$file.gz" ) { 
    #warn "Found zip version of file '$file'\n";
    open $FH, "zcat $file.gz|" or confess "Couldn't open file, '$file.gz'. $!";
  }
  
  
   else { 
    confess "Utility::Open_File !! Couldn't find file '$file'";
  }
  return $FH;
}


#################################################################### WRITE FILE
# Open a file, write the text, and close it. Simple.

sub Write_File { 
  my $file      = $_[0] || confess "Utility::Write_File !! No filename passed";
  my $contents  = $_[1] || confess "Utility::Write_File !! No contents passed";
  my $options   = $_[2] || {};

  # Deprecated usage with an overwite flag.
  if ( ref $options eq '' ) { $options = { overwrite => $options } }
 
  my $flag = ">";
  if ( -e $file ) {
    if ( $options->{overwrite} ) { 
      $flag = ">";
      print "Overwriting file $file\n";
      #unlink $file or confess "Couldn't delete file, '$file'. $!";
    } elsif ( $options->{append} ) { 
      $flag = ">>";
      print "Appending to file $file\n";
    } else { 
      confess "Utility::Write_File  File ('$file') already exists. Pass the overwrite flag to replace it.\n";
    }
  }

  open OUT, "$flag$file" or confess "Couldn't open file '$flag$file' for writing. $!";
  print OUT $contents or confess "Couldn't write to file, '$flag$file'. $!";
  close OUT or confess "Couldn't close file, '$flag$file'. $!";
}








##############################################################################
#                        MATRIX I/O SUBROUTINES
#-----------------------------------------------------------------------------
# Matrix I/O Options
#   overwrite   | bool      | overwrite an existing file
#   prefix_hash | bool      | prepend '#' to header row
#   header      | string    | line to print as header row
#   row_select  | [int]     | which rows to use
#   col_select  | [int]     | which columns to use
#   col_labels  | [string]  | labels to use for headers of columns
#   row_labels  | [string]  | labels to use for headers of rows
#   delimiter   | string    | column delimiter for split() or join()
#   data_format | string    | sprintf format applied to each cell
##############################################################################


############################################################### MATRIX TO TEXT
# Convert a 2D-array into text.

sub Matrix_to_Text {
  my $matrix = $_[0];
  my $options = $_[1] || {};

  my $string = "";
  
  if ( ref $matrix->[0] ne "ARRAY" ) { 
    confess "Utility::Matrix:to_Text !! Unknown data structured passed.\n" . Dumper($matrix);
  }

  #==== See if a long header is requested
  if ( exists $options->{header} ) { 
    $string .= $options->{header};
  }

  #==== Set column delimiter
  my $del = $options->{delimiter} || "\t";

  #==== Detect if subselections of rows and columns are requested
  my $height;
  my @row_select;
  if ( exists $options->{row_select} ) { 
    @row_select = @{$options->{row_select}};
    $height = scalar @row_select;
  } else { 
    $height = scalar @{$matrix};
    @row_select = 0..($height-1);
  }

  my $width;
  my @col_select;
  if ( exists $options->{col_select} ) { 
    @col_select = @{$options->{col_select}};
    $width = scalar @col_select;
  } else { 
    $width = scalar @{$matrix->[0]};
    @col_select = 0..($width-1);
  }
  

  #==== Detect and add column labels
  my @col_labels = ();
  my $col_width = 0;
  if ( exists $options->{col_labels} ) { 
    @col_labels = @{$options->{col_labels}};
    $col_width = scalar @col_labels;
    if ( $col_width != $width ) { 
      confess "Utility::Matrix_to_Text Columns are different width than matrix ($col_width vs. $width).\n" 
            . "Columns:\n" . ( Dumper(\@col_labels) ) 
            . "Matrix:\n"  . ( Dumper($matrix) );
    }
    my $title = $options->{title};
    if ( not defined $title ) { 
      #$title = 'MATRIX'
      $string .= join $del, @col_labels;
      $string .= "\n";
    } else { 
      $string .= join $del, $title, @col_labels;
      $string .= "\n";
    }
  }

  #==== Detect and prepare row labels
  my @row_labels = ();
  my $row_height = 0;
  if ( exists $options->{row_labels} ) { 
    @row_labels = @{$options->{row_labels}};
    $row_height = scalar @row_labels;
    if ( $row_height != $height ) { 
      confess "Utility::Matrix_to_Text Rows are different height than matrix ($row_height vs. $height).\n" . Dumper($matrix);
    }
  }


  #==== Build the matrix
  foreach my $i ( 0..$#row_select ) { 
    # Add a row label if it exists
    my $row = $row_select[$i];
    #print "$i - $row\n";
    if ( $row_height ) { $string .= $row_labels[$i] . $del }
    foreach my $c ( 0..$#col_select ) { 
      if ( $c != 0 ) { $string .= $del }

      my $col = $col_select[$c];
      my $datum = $matrix->[$row][$col];

      if ( not defined $datum and $options->{default} ) { 
        $string .= $options->{default};
        next;
      }

      if ( $options->{data_format} ) { 
        $string .= sprintf $options->{data_format}, $datum;
      } else { 
        $string .= $datum;
      }
    }
    $string .= "\n";
  }

  return $string;
}

################################################################## WRITE MATRIX
# Convert matrix to text, then write it to a file

sub Write_Matrix { 
  my $file = $_[0];
  my $matrix = $_[1];
  my $options = $_[2] || {};

  my $matrix_string = Matrix_to_Text($matrix, $options);

  Write_File($file, $matrix_string, ($options->{overwrite} || 0));
}


############################################################### TEXT TO MATRIX
sub Text_to_Matrix { 

  my $text    = $_[0];
  my $options = $_[1] || {};

  my @text;
  if ( ref $text eq 'ARRAY' ) { @text = @$text  }
  else                        { @text = ($text) }

  my $del = $options->{delimiter} || "\t";
  my @lines = map { split "\n", $_ }  @text;
  my @matrix = map { [ split /$del/, $_ ] } @lines;

  if ( $options->{transpose} ) { @matrix = Transpose(\@matrix) }
  if ( wantarray ) { return  @matrix }
  else             { return \@matrix }
}


###################################################### READ MATRIX FROM A FILE
sub Read_Matrix { 
  my $file = $_[0];
  my $options = $_[1] || {};
  my @lines = Read_File($file);
  my $matrix = Text_to_Matrix(\@lines, $options);
  if ( wantarray ) { return @$matrix}
  else             { return  $matrix}
}

######################################################### MATRIX TO HASH ARRAY
# Takes a 2D-Matrix with the first line being a header (basically read
# straight from a text file and split into tokens).  Column headers can also
# be passed in the option array and override reading the first line.
#
# Creates an array of hashes, where each row of the matrix is converted
# to a hash with the headers as keys and the row as values.
# 
# NOTE: This subroutine performs no error checking!

sub Matrix_to_Hash_Array { 

  my $matrix = $_[0];
  my $options = $_[1] || {};
  
  # If row major matrix, then transpose the matrix
  if ( $options->{rowmajor} ) {
    if ( $options->{colmajor} ) { 
      confess "Matrix_to_Hash_Array !! Cannot declare both rowmajor and colmajor matrix";
    }
    $matrix = Transpose($matrix);
  }

  # Deprecated use passing the header as a parameter. 
  if ( ref $options eq '' ) { $options = { header => $options } }


  # If a header was passed, use it, otherwise just take the first row.
  my $header;
  if ( $options->{header} ) { $header = $options->{header} }
  else                      { $header = shift @$matrix     }
  if ( not defined $header->[0] ) { 
    confess "Undefined header:\n" . Dumper($matrix) . $options;
  }
  $header->[0] =~ s/^#\s*//; # remove optional comment character
  my $width = scalar @$header;

  # If degenerate matrix (i.e. no data) then just return the header
  if ( scalar @$matrix == 0 ) { 
    return ([], $header);
  }

  # If length of row 0 is 1 less than the rest of the matrix, 
  # or if it is just space, assume the first column doesn't have a 
  # header (as read from a file), so just call it ROWHEADER.
  my $missing_row_header = 0;

  if ( $width == (scalar(@{$matrix->[0]})-1) ) { 
    $missing_row_header = 1;
    unshift @$header, "ROWHEADER";
    $width++;

  } elsif ( $header->[0] =~ /^\s*$/ ) { 
    $missing_row_header = 1;
    $header->[0] = "ROWHEADER";
    $width++;
  }


  # Build the array of hashes
  my @ha = ();
  foreach my $r ( 0..$#$matrix ) { 
    my $row = $matrix->[$r];
    my $row_width = scalar @$row;
    if ( $row_width != $width ) { 
      confess "Matrix_to_Hash_Array !! Matrix is not a consistent width: (header: $width vs. row $r: $row_width)\n" 
            . "Options: \n" . Dumper($options) . "\n"
            . "Header:\n"   . Dumper($header)  . "\n"
            . "Matrix:\n"   . Dumper($matrix);
    }

    foreach my $c ( 0..$#$header ) { 
      my $col = $header->[$c];
      $ha[$r]{$col} = $matrix->[$r][$c];
    }
  }

  # Always return the header since you don't know if it was passed in or not.
  return \@ha, $header;
}

############################################### READ ARRAY OF HASHES FROM FILE
sub Read_Hash_Array { 
  my $file    = $_[0];
  my $options = $_[1];
  my $matrix  = Read_Matrix($file, $options);
  return Matrix_to_Hash_Array($matrix, $options);
}


##################################################### MATRIX TO HASH OF HASHES
sub Matrix_to_Hash_Hash {
  my $matrix  = $_[0];
  my $options = $_[1] || {};
  
  my ($ha, $cols) = Matrix_to_Hash_Array($matrix, $options);

  my @rows = ();
  my %hh = ();
  foreach my $row ( @$ha ) { 
    my %row = %$row;
    my $row_header = $row->{$cols->[0]};
    push @rows, $row_header;
    $hh{$row_header} = $row;
  }

  return (\%hh, \@rows, $cols);
}


################################################ READ HASH OF HASHES FROM FILE
sub Read_Hash_Hash { 
  my $file    = $_[0];
  my $options = $_[1] || {};
  
  my $matrix = Read_Matrix($file, $options);
  my ($ha, $rows, $cols) = Matrix_to_Hash_Hash($matrix, $options);
  return ($ha, $rows, $cols);
}




######################################## IDENTIFY COLUMN SELECTION FROM HEADER
# Given a header string and various column specifications, get the map of 
# column indices corresponding to selected header names.
# Header must already be split into column names.
# Allow integers to negatively index, but correct them to real index.

sub Identify_Column_Selection_from_Header {

  my $headers = $_[0] or confess "Need a header line.";
  my $select = $_[1] || {};

  my @headers = @$headers;  # Indexed Header Array
  my $width  = scalar @headers;
  my @indices = (); # Final list of selected indices

  my @select_ints = @{ $select->{INTS} || [] };
  my @select_strs = @{ $select->{STRS} || [] };
  my @select_rgxs = @{ $select->{RGXS} || [] };
  my $case_sen     = $select->{CASE} || 0;
              
  my $header_line = join "\n", map { sprintf "%5d: '%s'", $_, $headers[$_] } 0..$#headers;
  
  #=============== Reverse map column names to indices
  my %headers = ();
  foreach my $i ( 0..$#headers ) { 
    $headers{$headers[$i]} = $i;
  }

 
  #=============== Push all integer indices that are within range 
  foreach my $int ( @select_ints ) { 
    
    #----------- Index is too large (positive or negative)
    if ( abs($int) > $width ) { 
      if ( $select->{VERIFY} ) { 
        confess "Header index $int is out of range (max $width).";
      } else { 
        next;
      }

    }

    #----------- Headers are 1-Indexed, 0 has no meaning
    if ( $int == 0 ) { 
      if ( $select->{VERIFY} ) { 
        confess "Headers are 1-indexed, but was passed an index 0";
      } else { 
        next; 
      }
    }

    #----------- Convert to 0-index and make sure it's defined
    my $i;
    if ( $int  > 0 ) { $i = $int-1 }
    else             { $i = $width - $int + 1 }
    if ( not defined $headers[$i] ) { 
      confess "Header $int is not defined for some reason:\n$header_line\n";
    }

    if ( $select->{VERBOSE} ) { print "Found int header $int: $headers[$i]\n" }
    push @indices, $i;
  }

  #=============== Strings Exactly Matching Header Names
  foreach my $i ( 0..$#select_strs ) { 
    my $str = $select_strs[$i];
    my @h;
    if ( $case_sen ) { @h = grep {    $headers[$_] eq    $str } 0..$#headers }
    else             { @h = grep { uc $headers[$_] eq uc $str } 0..$#headers }

    #----------- Matched One or More Columns
    if ( @h > 0 ) { 
      if ( @h > 1 and $select->{VERIFY} ) { 
        confess "Matched multiple columns with '$str':\n$header_line\n";
      }

      if ( $select->{VERBOSE} ) { 
        print "Found " . scalar @h . " headers matching $str\n";
      }
      push @indices, @h;
      next;
    }
   
    #----------- No Matches
    if ( $select->{VERIFY} ) { 
      confess "Could not find column named '$str':\n$header_line\n";
    }
  }

  #=============== String Matches Regexp
  foreach my $i ( 0..$#select_rgxs ) { 
    my $rgx = $select_rgxs[$i];
    my $matched_re = 0;
    foreach my $h ( 0..$#headers ) { 
      my $header = $headers[$h];
      my $match = 0;
      if ( $case_sen ) { if ( $header =~ /$rgx/  ) { $match = 1 } } 
      else             { if ( $header =~ /$rgx/i ) { $match = 1 } } 
       
      if ( $match ) { 
        if ( $select->{VERBOSE} ) { 
          print "Found $header matching regex /$rgx/\n";
        }
        push @indices, $h; 
        $matched_re = 1;
      }
    }

    if ( not $matched_re ) { 
      if ( $select->{VERIFY} ) { 
        confess "Regular expression /$rgx/ did not match any headers:\n$header_line\n";
      }
    }
  }

  
  #=============== Package and Ship it.

  

  

}





##############################################################################
#                                                   GENERAL CONFIGURATION FILE
##############################################################################

############################################## FETCH ARGUMENT

sub Fetch_Argument { 
  my $name  = $_[0] // confess "Utility::Fetch_Argument !! No name passed.";
  my $lines = $_[1] // confess "Utility::Fetch_Argument !! No lines passed.";
  my $min   = $_[2];
  my $max   = $_[3];

  # Match lines with argument name and trim off the name
  my @args = map { /^$name\s+(.*)$/i; $1 } grep { /^$name\s/i } @$lines;


  # Confirm min/max argument count restrictions
  my $count = scalar @args;
  if ( defined $min and $count < $min ) { 
    confess "Summary::Fetch_Argument !! Too few arguments for '$name' in config file. " 
      . "Min: $min  Found: $count\n"
      . "  " . (join ',', @args) . ")";
  }
  if ( defined $max and $count > $max ) { 
    confess "Summary::Fetch_Argument !! Too many arguments for '$name' in config file. "
      . "Max: $max  Found; $count\n"
      . "  " . (join ',', @args) . ")";
  }

  # Return a single argument (instead of an array) as a convenience when
  # a single argument is requested.
  if ( defined $max and $max == 1 ) { return $args[0] || undef }

  # Return all relevant configuration lines
  if ( wantarray ) { return  @args }
  else             { return \@args }
}






##############################################################################
#                                                        TRAY CONDITIONS FILES
##############################################################################

sub Read_Conditions_Files { 

  my $files = $_[0] or croak "Not passed condition file.\n";
  my @files = ();
  if ( ref $_[0] eq 'ARRAY' ) { 
    @files = @{$_[0]};
  } elsif ( ref $files eq '' ) { 
    @files = (@_);
  } else { 
    croak "Unknown argument passed, '$files'.\n";
  }


  ##### Parse Conditions Files
  my %conditions = ();
  
  foreach my $cond_file ( @files ) { 

    my ($path, $dir, $file) = Split_Path($cond_file);
    my $label = $file;
    $label =~ s/\.cond//g;
    
    
    my %cond = ();
    #print "\t$label\n" if $VERBOSE >= 3;
    my @contents = Read_File($path);
    foreach my $line ( @contents ) { 
      chomp $line;
      $line =~ s/#.*//g;					# ignore comments
      next if $line =~ /^\s*$/;  # skip empty lines
      #print "$line\n";

      # Parse location ranges in the specification
      my ($spec, $desc) = split /:/, $line;
      $spec = uc $spec;
      my @specs = ();
      my ( $loc_type, $loc_range ) = split /\s+/, $spec, 2;

      #---- Multiple Rows or Columns
      if ( ($loc_type eq 'COLUMNS') or ($loc_type eq 'ROWS') ) { 
        my $type = $loc_type;
        $type =~ s/S//i;
        my @loc_range = Parse_Range($loc_range);
        foreach my $range ( @loc_range ) { 
          #print "Columns: $type $range\n";
          push @specs, "$type $range";
        }

      #---- Multiple Wells or Drops
      } elsif ( ($loc_type eq 'WELLS') or ($loc_type eq 'DROPS') ) { 
        my $type = $loc_type;
        $type =~ s/s//i;
        $loc_range =~ /^([\w\-\,]+?)([\d\-\,]+?)$/;
        my ( $rows, $cols ) = ( $1, $2 );
        my @rows = Parse_Range($rows);
        my @cols = Parse_Range($cols);
        foreach my $row ( @rows ) { 
          foreach my $col ( @cols ) { 
            push @specs, "$type $row$col";
          }
        }

      #---- Abbreviated Col instead of Column
      } elsif ( $loc_type eq 'COL' ) { 
        @specs = ("Column $loc_range");
      
      #---- All other specifications
      } else { 
        #print "Normal spec $spec: $desc\n";
        @specs = ($spec);
      }


      # Clean up the description
      #print "$spec: $desc\n";
      $desc = join ";", 
                   grep { not $_ eq '' } 
                   grep { not ('NONE' eq (uc $_)) }  
                   map { Utility::Trim($_) } 
                   split ';', $desc
                   ;
      foreach my $s ( @specs ) { 
        #print "Pushing $spec - $s: $desc\n";
        if ( exists $cond{$s} ) { $cond{$s} .= ";$desc" }
        else                    { $cond{$s}  =   $desc  }
      }
    }

    $conditions{$label} = \%cond;
  }


  ###### Process Include Files
  my ( $name, $cond );
  my $include_count = 0;
  while (($name,$cond) = each %conditions) { 

    if ( exists $cond->{'INCLUDE'} ) { 
      #print "Found Include in $name\n" if $VERBOSE >= 3;
      $include_count++;
      my @includes = map { Trim($_) } split ";", $cond->{'INCLUDE'};
                        
      foreach my $inc_file ( @includes ) { 
        $inc_file =~ s/\.cond$//; 
        if ( exists $conditions{$inc_file} ) { 
          my $inc = $conditions{$inc_file};
          foreach my $idx_key ( keys %$inc ) { 
            my $c = join ";", 
                         grep { not ('NONE' eq (uc $_)) }  
                         map { Utility::Trim($_) } 
                         split ';', $inc->{$idx_key}
                         ;
            
            if ( not exists $cond->{$idx_key} ) { 
              #print "Adding condition $idx_key $inc->{$idx_key}\n";
              $cond->{$idx_key} = $c;
            } else { 
              #print "Append condition $idx_key $inc->{$idx_key}\n";
              $cond->{$idx_key} .= ";$c";
            }
          }
        } else { 
          croak "Could not find include file $inc_file for condition '$name', '$cond'.\n";
        }
      }
    }
  }
  #print "   Found $include_count files with include statements\n";


  if   ( wantarray ) { return  %conditions }
  else               { return \%conditions }
}



##############################################################################
##############################################################################
#                                                        PDB PARSING
##############################################################################
##############################################################################

################################################### WRITE PDB SIMPLE

sub Write_PDB_Simple { 

  my $file      = $_[0];
  my $molecules = $_[1];

  #===== Open pdb file
  open FH, ">$file" or confess "Couldn't open pdb file for writing, '$file'. $!";

  #===== Print Box Size
  print FH "REMARK BOX 100.0 100.0 100.0\n";

  #===== Loop over residues by index
  my $atom_count = 1;
  foreach my $m ( 0..$#$molecules ) { 
    my $pdb = $molecules->[$m];
    my $atom_number = 1;

    #print "MOLECULE $m\n";

    foreach my $i ( 0..($pdb->{'length'}-1) ) { 

      #print "  RESIDUE $i\n";

      #===== Get residue information
      my $res_num = $pdb->{'res_nums'}[$i];
      my $icode   = $pdb->{'icodes'  }[$i];
      my $residue = $pdb->{'sequence'}[$i];
      my $atoms   = $pdb->{'residues'}[$i];

      #===== Get atom order, or do alphabetical for unknown residues
      my $order   = $ATOM_ORDER{$residue};
      if ( not defined $order ) { 
        if ( $pdb->{'res_orders'}[$i] ) { 
          $order = $pdb->{'res_orders'}[$i];
          #print STDERR "Using RESIDUE order $res_num\n";
        } elsif ( $pdb->{'orders'}{$residue} ) { 
          $order = $pdb->{'orders'}{$residue};
          #print STDERR "Using INPUT order $res_num\n";
        } else { 
          $order = [ sort keys %$atoms ];
          #print STDERR "Using SORT order $res_num\n";
        }
      } else { 
        #print STDERR "Using ATOM ORDER $res_num\n";
      }

      #===== Write known atoms
      foreach my $atom ( @$order ) { 
        if ( exists $atoms->{$atom} ) { 

          my %atom = %{$atoms->{$atom}};

          # Special justification for atom names for stupid pdb parsers
          my $atom_out = $atom;
          if ( length $atom_out <= 3 ) { $atom_out = ' ' . $atom_out; }

          # Atom Properties
          my $x = $atom{'x'};
          my $y = $atom{'y'};
          my $z = $atom{'z'};
          my $o = $atom{'o'}; $o = (defined $o and $o=~/\S/) ? sprintf "%6.2f", $o : "";
          my $t = $atom{'t'}; $t = (defined $t and $t=~/\S/) ? sprintf "%6.2f", $t : "";

          # Placeholders for now
          my $chain   = $atom{'chain'  } || '';
          my $alt_loc = $atom{'alt_loc'} || '';
          my $segment = $atom{'segment'} || '';
          my $element = $atom{'elem'   } || '';
          my $charge  = $atom{'charge' } || '';

          # Write it
          printf FH "%-6s%5i %-4s%1s%3s %1s%4d%1s   %8.3f%8.3f%8.3f",
            'ATOM', $atom_number++,
            $atom_out, $alt_loc, $residue, 
            $chain, $res_num, $icode,
            $x, $y, $z,
            ;
            
          if ( $o or $t or $segment or $element or $charge ) { 
            printf FH "%6s%6s      %-4s%2s%2s\n",
              $o, $t, $segment, $element, $charge,
              ;
          } else { 
            print FH "\n";
          }

        # Assume we can get away without hydrogens
        } else { 
          if ( 0 and $atom !~ /^H/ ) { 
            confess "Missing required atom '$atom' in residue $res_num $residue";
          }
        }
      }
    }
    #===== Print molecule termination
    print FH "TER\n";
  }


  #===== Close file
  close FH or confess "Couldn't close pdb file, '$file'. $!";


}


#################################################### READ PDB SIMPLE

sub Read_PDB_Simple { 

  my $pdb = $_[0] or confess "Utility::Read_PDB was not passed a pdb file";

  my $FH = Open_File ( $pdb );

  #===== Read Lines

  my $line;
  my $res_i = -1;
  my $last_r_num = -10;
  my $last_icode = '';

  my %orders = ();
  my $ordering = 0;

  my @molecules = ();
  my $mol_index = 0;
  my $mol = $molecules[0] = {};

  while ( defined ( $line = <$FH> ) ) {
  
    if ($line =~ /^TER/) { 
      $mol = $molecules[++$mol_index] = {};
      $res_i = -1;
      $last_r_num = -10;
      $last_icode = '';
      next;
    }
    next if not $line =~ /^ATOM/;
    if ( length $line < 80 ) { $line .= ' ' x 80 }

    #===== Parse the Line
    my ( $type,   $a_num, 
         $a_type, $alt_loc, $r_type, 
         $chain, $r_num,  $icode, 
         $x, $y, $z, $o, $t, 
         $segment, $elem, $charge) =
        unpack "A6A5xA4A1A3xA1A4A1xxxA8A8A8A6A6xxxxxxA4A2A2", $line;
    #print "ATOM '$a_num' '$a_type',  '$r_type' '$r_num' '$x' '$y' '$z'\n";
  
    #===== Cleanup Fields
    $type       = Trim ( $type    );
    $a_num      = int  ( $a_num   );
    $a_type     = Trim ( $a_type  );
    $alt_loc    = Trim ( $alt_loc );
    $r_type     = Trim ( $r_type  );
    $chain      = Trim ( $chain   );
    $r_num      = int  ( $r_num   );
    $icode      = Trim ( $icode   );
    $x          = $x + 0;
    $y          = $y + 0;
    $z          = $z + 0;
    $o          = $o =~ /\S/ ? $o + 0 : '';
    $t          = $t =~ /\S/ ? $t + 0 : '';
    $segment    = Trim ( $segment );
    $elem       = Trim ( $elem    );
    $charge     = $charge || "";
    #$charge     = $charge =~ /\d/ ? int ( $charge ) : '';

    #==== Account for broken pdb formats in stupid molecular dynamics packages
    # Assume alternate locations are always a letter.  If they are a number
    # then it was probably part of an atom name.
    if ( $alt_loc =~ /\d/ ) { 
      $a_type .= $alt_loc; 
      $alt_loc = '';
    }

    
    #===== Standardize Atom Names
    my $a_conv = $a_type;
    if ( exists $ATOM_NAME_TRANSLATION_LOOKUP{$a_type} ) { 
      $a_conv = $ATOM_NAME_TRANSLATION_LOOKUP{$a_type};
    }

    #===== Start a new residue, keeping our own index
    if ( ($last_r_num != $r_num) or ($last_icode ne $icode) ) { 
      #print "Found new residue $r_num $r_type\n";
      $last_r_num = $r_num;
      $res_i++; 
      $mol->{'residues'}[$res_i] = {};
      $mol->{'sequence'}[$res_i] = $r_type;
      $mol->{'res_nums'}[$res_i] = $r_num;
      $mol->{'icodes'  }[$res_i] = $icode;
      if ( not exists $ATOM_ORDER{$r_type} 
       and not exists $orders{$r_type} ) { $ordering = 1 } 
      else                               { $ordering = 0 }
    } 

    if ( $ordering ) { 
      #push @{$orders{$r_type}}, $a_type;
      push @{$mol->{'res_orders'}[$res_i]}, $a_type;
    }

    $mol->{'residues'}[$res_i]{$a_conv} = {
      a_num   => $a_num,
      a_type  => $a_type,
      alt_loc => $alt_loc,
      r_type  => $r_type,
      chain   => $chain,
      r_num   => $r_num,
      icode   => $icode,
      x       => $x,
      y       => $y,
      z       => $z,
      o       => $o,
      t       => $t,
      segment => $segment,
      elem    => $elem,
      charge  => $charge,
    };

  }

  close $FH;
  #close $FH or confess "Couldn't close pdb file, '$pdb'. $!";


  foreach my $m ( @molecules ) { 
    $m->{'start_res'} = $m->{'res_nums'}[ 0];
    $m->{'end_res'  } = $m->{'res_nums'}[-1];
    $m->{'length'   } = scalar @{$m->{'res_nums'}};
  }


  if ( wantarray ) { return  @molecules }
  else             { return \@molecules }
}





##############################################################################
#                                                  READ PDB ADVANCED
##############################################################################



################################################### WRITE CRD SIMPLE

sub Write_CRD_Simple { 

  my $file = $_[0];
  my $mols = $_[1];
  
  if ( not defined $file ) 
    { confess "First argument must be a file name" }
  if ( not ref $mols eq 'ARRAY' ) 
    { confess "Second argument must be a molecule array reference" }

  #===== Open crd file
  open FH, ">$file" or confess "Couldn't open crd file for writing, '$file'. $!";

  #===== Loop over molecules
  foreach my $m ( 0..$#$mols ) {
    my $mol = $mols->[$m];

    #===== Loop over residues by index
    my $atom_count = 1;
    foreach my $i ( 0..($mol->{'length'}-1) ) { 

      #===== Get residue information
      my $res_num = $mol->{'res_nums'}[$i];
      my $icode   = $mol->{'icodes'  }[$i];
      my $residue = $mol->{'sequence'}[$i];
      my $atoms   = $mol->{'residues'}[$i];

      #===== Get atom order, or do alphabetical for unknown residues
      my $order   = $ATOM_ORDER{$residue};
      if ( not defined $order ) { 
        if ( $mol->{'orders'}{$residue} ) { $order = $mol->{'orders'}{$residue} }
        else { confess "Cannot write CRD files without a definite order" }
      }

      #===== Write known atoms
      foreach my $atom ( @$order ) { 
        
        if ( exists $atoms->{$atom} ) { 
          
          # Get Atom
          my %atom = %{$atoms->{$atom}};
          
          # Atom Properties
          my $x = $atom{'x'};
          my $y = $atom{'y'};
          my $z = $atom{'z'};

          # Print coordinates
          printf FH "%.3f %.3f %.3f\n", $x, $y, $z;

        # Assume we can get away without hydrogens
        } else { 
          if ( $atom !~ /^H/ ) { 
            confess "Missing required atom '$atom' in residue $res_num $residue";
          } else { 
            printf FH "%.3f %.3f %.3f\n", rand(1), rand(1), rand(1);
          }
        }
      }
    }

    #===== Print Box Size
    print FH "100.0 100.0 100.0\n";
  }

  #===== Close file
  close FH or confess "Couldn't close pdb file, '$file'. $!";

}


#################################################### READ CRD SIMPLE

sub Read_CRD_Simple { 
  my $file = $_[0];
  my $seq  = $_[1];

  #===== Open File
  my $FH = Open_File ( $file );

  my @molecules = ();

  my $mol_index = 1;
  my $res_index = 1;
  my $atm_index = 1;

  my @expected_atoms = ();
  foreach my $res ( @$seq ) { 
    my $order = $ATOM_ORDER{$res};
    foreach my $atom ( @$order ) { 
      my %a = (
        a_num   => $atm_index++,
        a_type  => $atom,
        r_num   => $res_index,
        r_type  => $res,
      );
      push @expected_atoms, \%a;
    }
    $res_index++;
  }

  my $complete_frame = 0;
  my $line;
  my $index = 0;
  
  $mol_index = 0;
  $res_index = 0;
  $atm_index = 0;

  my $protein_length = scalar @$seq;

  while ( defined ( $line = <$FH> ) ) {

    #print $line;

    # Finished a frame, read the box, can end now
    if ( $index == scalar @expected_atoms ) { 
      my $box = $line;
      $complete_frame = 1;
      $molecules[$mol_index]{'sequence' } = $seq;
      $molecules[$mol_index]{'res_nums' } = [1..$protein_length];
      $molecules[$mol_index]{'icodes'   } = [('') x $protein_length];
      $molecules[$mol_index]{'start_res'} = 1;
      $molecules[$mol_index]{'end_res'  } = $protein_length;
      $molecules[$mol_index]{'length'   } = $protein_length;
      $mol_index++;
      $index = 0;
      next;
    } else { 
      $complete_frame = 0;
    }
    
    # Read the line
    my $atom = $expected_atoms[$index++];
    my ( $x, $y, $z ) = split /\s+/, $line;
    my $res_index = $atom->{'r_num'} - 1;

    # Create the atom
    $molecules[$mol_index]{'residues'}[$res_index]{$atom->{'a_type'}} = {
      m_num   => $mol_index+1,
      a_num   => $atom->{'a_num'},
      a_type  => $atom->{'a_type'},
      r_num   => $atom->{'r_num'},
      r_type  => $atom->{'r_type'},
      x       => $x + 0,
      y       => $y + 0,
      z       => $z + 0,
    };

  }

  if ( not $complete_frame ) { 
    confess "Incomplete frame in CRD readers"
  }

  if ( wantarray ) { return  @molecules }
  else             { return \@molecules }

}


###############################################################################
#                                                                 Atom to PyMOL
#------------------------------------------------------------------------------
# Convert an atom structure to a pymol atom selction
# TODO: This makes more sense than Residue_to_PyMOL, but depends on it, so 
# double check it.
###############################################################################


sub Atom_to_PyMOL { 
  my $atom = $_[0];
  my @selection = Residue_to_PyMOL($atom);
  if ( $atom->{atom} ) { push @selection, "(name $atom->{atom})" }
  if ( $atom->{alt}  ) { push @selection, "(alt  $atom->{alt})" }
  
  if ( wantarray ) { return @selection }
  else             { return "(" . (join ' and ', @selection) . ")" }
}

###############################################################################
#                                                              Residue to PyMOL
#------------------------------------------------------------------------------
# Converts a residue structure to a pymol residue selection
# TODO: Suspect it's broken, or it doesn't do what I think it does.
###############################################################################

sub Residue_to_PyMOL { 
  my $res = $_[0];
  my $atom;
  my @selection = ();
  if ( $res->{structure} ) { push @selection, $res->{structure} }
  if ( $res->{chain    } ) { push @selection, $res->{chain    } } 
  if ( $res->{resi     } ) { push @selection, $res->{resi     } } 

  if ( wantarray ) { return @selection }
  else             { return "(" . (join ' and ', @selection) . ")" }
}







##############################################################################
##############################################################################
#                           SEQUENCE/GENETICS FUNCTIONS
##############################################################################
##############################################################################



##############################################################################
#                                                          SEQUENCE ALIGNMENTS
##############################################################################

################################################ PARSE SEQUENCE ALIGNMENT FILE
# Probably assumes fasta format. Should check/generalize. Maybe use bioperl
# for this kind of thing.
# TODO: Document this stuff.
sub Parse_Sequence_File { 

  my $seq_file = $_[0] or confess "no sequence file passed\n";

  if ( not -e $seq_file ) { confess "Couldn't find sequence file, '$seq_file'."; }
  my @seq_lines = split "\n", `cat $seq_file`;

  my %SEQ = ();

  foreach my $line ( @seq_lines ) { 
    next if $line =~ /^\s*$/;
    my ( $species, $sequence, $final ) = split /\s+/, $line;
    if ( not exists $SEQ{$species} ) { 
      $SEQ{$species} = [split //, $sequence];
      #print "Creating $species\n";
    } else { 
      push @{$SEQ{$species}}, split //, $sequence;
      #print "Pushing $species\n";
    }
  }

  if ( not exists $SEQ{'CONSENSUS'} ) { 
    confess "No consensus sequence in sequence\n";
  }

  my %IDX = ();
  my %XDI = ();
  
  my @species = sort keys %SEQ;
  my $con_length = scalar @{$SEQ{'CONSENSUS'}};
  foreach my $species ( @species ) { 
    my $sp_length = scalar @{$SEQ{$species}};
    if ( $sp_length != $con_length ) { 
      confess "Length of species ($species, $sp_length) differs from consensus length ($con_length)\n";
    }
    my $index = 0;
    foreach my $i ( 0..$con_length-1 ) { 
      if ( $SEQ{$species}[$i] eq '.' ) { 
        $SEQ{$species}[$i] = $SEQ{'CONSENSUS'}[$i];
      }
      my $res = $SEQ{$species}[$i];
      if ( $res ne '-' ) {
        $IDX{$species}[$i    ] = ++$index;
        $XDI{$species}[$index] = $i;
      } else { 
        $IDX{$species}[$i    ] = -1;
      }
    }
  }

  return { seq => \%SEQ, idx => \%IDX, xdi => \%XDI };
}


sub Seq_Map { 
  my $map = $_[0];
  my $sp1 = $_[1];
  my $sp2 = $_[2];
  my $idx = $_[3];
  my $con = $map->{'xdi'}{uc $sp1}[$idx];
  my $i   = $map->{'idx'}{uc $sp2}[$con];
  my $res = $map->{'seq'}{uc $sp2}[$con];
  return $i, $res;

}

sub Seq_Translate_Index { 
  my $map = $_[0];
  my $sp1 = $_[1];
  my $sp2 = $_[2];
  my $idx = $_[3];
  if ( ref $idx eq 'ARRAY' ) {
    my @trans = ();
    foreach my $x ( @$idx ) { 
      my ( $i, $res ) = Seq_Map ( $map, $sp1, $sp2, $x );
      push @trans, $i;
    }
    if ( wantarray ) { return  @trans }
    else             { return \@trans}

  } else { 
    my ( $i, $res ) = Seq_Map ( $map, $sp1, $sp2, $idx );
    return $i;
  }
}

sub Seq_Translate_Residue { 
  my $map = $_[0];
  my $sp1 = $_[1];
  my $sp2 = $_[2];
  my $idx = $_[3];
  if ( ref $idx eq 'ARRAY' ) {
    my @trans = ();
    foreach my $x ( @$idx ) { 
      my ( $i, $res ) = Seq_Map ( $map, $sp1, $sp2, $x );
      push @trans, $res;
    }
    if ( wantarray ) { return  @trans }
    else             { return \@trans}

  } else { 
    my ( $i, $res ) = Seq_Map ( $map, $sp1, $sp2, $idx );
    return $res;
  }
}

#################################### ADJUST RESIDUES BY SEQUENCE MAP

sub Adjust_Residues_by_Sequence_Map { 
  my $map         = $_[0];
  my $start_res   = $_[1];
  my $finish_res  = $_[2];
  my $sp_from     = $_[3];
  my $sp_to       = $_[4];
  my $residues    = $_[5];
  my @idx_real = grep { $_ >= $start_res and $_ <= $finish_res } 
                      Utility::Seq_Translate_Index ( $map, $sp_from, $sp_to, $residues );
  my @idx_1    = map { $_ - $start_res + 1 } @idx_real;
  my @idx_0    = map { $_ - 1 } @idx_1;
  return \@idx_real, \@idx_0, \@idx_1; 
}



########################################## ADJUST RESIDUES BY OFFSET

sub Adjust_Residues_by_Offset {
  my $residues  = $_[0];
  my $offset    = $_[1];
  my $start     = $_[2];
  my $finish    = $_[3];

  my @offsets = ();
  
  foreach my $res ( @$residues ) { 
    my $off = $res + $offset;
    if ( $off < $start  ) { $off = $start  }
    if ( $off > $finish ) { $off = $finish }
    push @offsets, $off;
  }
  @offsets = sort { $a<=>$b } Utility::Unique(@offsets);

  my @res_idx_0 = map { $_ - $start     } @offsets;
  my @res_idx_1 = map { $_ - $start + 1 } @offsets;

  return (\@offsets, \@res_idx_0, \@res_idx_1);
}




##############################################################################
##############################################################################
#                               JOB EXECUTION
##############################################################################
##############################################################################


######################################################## FLAGS FOR TRY COMMAND
our %FLAGS_TRY_COMMAND = (
  verbose => 3,
);

#################################################################### SET FLAGS
sub Set_Flags { 

  my $source = $_[0];
  my $target = $_[1];

  return if not $source or not ref $source eq 'HASH';
  return if not $target or not ref $target eq 'HASH';

  my ($key,$value);
  while ( ($key,$value) = each %$source ) { 
    $target->{$key} = $value;
  }
}

################################################################## TRY COMMAND
# Attempts to execute a command (if in RUN mode).  Processes any
# return values.  Prints progress.
# Flags:
#   verbose     : chattiness. See mostly Report_Error
#   fatal       : die if command failes
#   validate    : call Validate subroutine
#   write_file  : Report_Error can write an error file

sub Try_Command {
  my $command   = $_[0];
  my $desc      = $_[1];
  my $flags     = $_[2] || {};

  my %flags = (%FLAGS_TRY_COMMAND, %$flags);

  #=============== Report
  print "$desc\n"    if $flags{'verbose'} >= 1;
  print "$command\n\n" if $flags{'verbose'} >= 2;

  #=============== Execute Command and Collect STDOUT/STDERR
  my $pid = open3(\*CHILD_IN, \*CHILD_OUT, \*CHILD_ERR, $command);
  #my $child_in = join "\n", <CHILD_IN>;
  my $child_out = join "", <CHILD_OUT>;
  my $child_err = join "", <CHILD_ERR>;
  waitpid( $pid, 0 );

  #=============== Get Result
  my $value   = $?;
  my $status  = $? >> 8;
  
  #=============== Create Error Report
  my %report = (
      try_command_report  => 1,
      value               => $value,
      desc                => $desc,
      message             => '',
      command             => $command,
      out                 => $child_out,
      err                 => $child_err,
  );

  ################ Command Failed

  if ( $value ) { 

    #============= Interpret return value

    $report{command_error} = 1;
    $report{error_class  } = 'execution';

    if ( $value == -1 ) { 
      $report{message} = "Command failed to execute. $!\n";
    } elsif ( $value & 127 ) { 
      $report{message} = 
        sprintf "Command died with signal %d, %s coredump\n"
              , ($value & 127), ($value & 128) ? 'with' : 'without'
              ;
    } else { 
      $report{message} = "Command failed and exited with value $status\n";
    }

    
    #============= Report Error
    if ( $flags->{verbose} or $flags->{verbose_error} ) { 
      Report_Error ( $report{message}, \%report, $flags );
    }
    
    #============= Die if fatal
    exit 1 if $flags->{fatal};
    
    if ( wantarray ) {  return  %report }
    else             {  return \%report }
  }



  ################ Command Generated Warnings
  if ( $flags->{stderr_fatal} and $child_err ) { 
    $report{error_class} = 'stderr';
    $report{message    } = 'Program generated warnings to standard error.';
    Report_Error ( $report{message}, \%report, $flags );
    return (wantarray ? %report : \%report);
  }



  ################ Command Succeeded
  if ( $flags->{validate} or $flags->{verify} ) { 
    my ($err_in, $err_out) = 
      Verify_Analysis_Files($desc, $flags->{inputs}, $flags->{outputs}, $flags);
  
    #----------- Found errors, pass them along  
    if (scalar @$err_in or scalar @$err_out) { 
      return { 
        try_command_report  => 1,
        command_error       => 0, 
        validation_error    => 1,
        value               => $value,
        desc                => $desc,
        command             => $command,
        message             => 'Error verifying analysis files',
        out                 => '',
        err                 => '',
        error_inputs        => $err_in,
        error_outputs       => $err_out,
      };
    }
  }
  return;

}

################################################ BACKUP SUMMARY FILE

sub Backup_File_With_Date {
  my $file = $_[0];
  return if not -e $file;

  #===== Get File Modification Time
  my $age  = -M $file;
  my $date = time - $age;

  #===== Don't backup if file is relatively new (i.e. today)
  if ( $age < 60*60*24 ) { return $file }

  #===== Date format is YYYY-MM-DD
  my $str = POSIX::strftime ("%F", localtime ($date));
  my $new = $file . $str;

  #===== If that file already exists, diff them to see if same
  my @suffixes = ("", map { ".$_" } 1..1000);
  foreach my $s ( @suffixes ) { 
    my $new_s = $file . $s;
    if ( -e $new_s ) { 
      my $diff = `diff --brief $file $new_s`;
      if ( not $diff ) { return $new_s }
    } else { 
      `cp $file $new_s`;
      return $new_s;
    }
  }
  confess "Could not fine new name for file $file";
}





####################################################### VERIFY ANALYSIS OUTPUT
# Verifies several details of analysis output files relative to inputs.  
# Verifies inputs as well, since it is expected that job won't execute 
# correctly with missing/corrupt input files.
#   1) all input and output files exist
#   2) all input and output files are non-zero
#   3) all output files are newer than all input files
# Returns 0 for success, else there is a description of the problem.

sub Verify_Analysis_Files { 

  my $analysis  =   $_[0];
  my @inputs    = @{$_[1]};
  my @outputs   = @{$_[2]};
  my $flags     =   $_[3] || {};
  if ( $flags->{fatal} ) { $flags->{fatal_in} = 1; $flags->{fatal_out} = 1; }

  my @errors_in    = ();
  my @errors_out   = ();
  my @good_inputs  = ();
  my @good_outputs = ();

  my $newest_input_file;
  my $newest_input_time;


  #---- Verify Input Files
  foreach my $i ( 0..$#inputs ) { 
    my @e = ();
    my $file = $inputs[$i];
    if ( not defined $file ) { push @e, "Input file #$i is not defined."    }
    elsif (   not -e $file ) { push @e, "Input file #$i '$file' does not exists." }
    elsif (       -z $file ) { push @e, "Input file #$i '$file' is of zero size." }
    if ( scalar @e ) { 
      push @errors_in, @e;
      $good_inputs[$i] = 0;
      next;
    } else { 
      $good_inputs[$i] = 1;
      my $time = -M $file;
      if ( not defined $newest_input_time or $time < $newest_input_time ) { 
        $newest_input_time = $time;
        $newest_input_file = $file;
      }
    }
  }


  #---- Verify Output Files
  foreach my $o ( 0..$#outputs ) { 
    my @e = ();
    my $file = $outputs[$o];
    if ( not defined $file ) { push @e, "Output file #$o is not defined."    }
    elsif (   not -e $file ) { push @e, "Output file #$o '$file' does not exists." }
    elsif (       -z $file ) { push @e, "Output file #$o '$file' is of zero size." }
    elsif ( -M $file > $newest_input_time ) { 
      push @e, "Output file #$o '$file' is older than input file '$newest_input_file'."
    }

    if ( scalar @e ) { 
      $good_outputs[$o] = 0;
      push @errors_out, @e;
      next;
    } else { 
      $good_outputs[$o] = 1;
    }
  }

  my $errors_in  = join "", map { "  $_\n" } @errors_in;
  my $errors_out = join "", map { "  $_\n" } @errors_out;

  if ( ( $flags->{fatal_in } and scalar @errors_in  > 0) 
    or ( $flags->{fatal_out} and scalar @errors_out > 0 ) ) {  
    confess "There were errors with the input/output files for analysis '$analysis':\n" 
          . $errors_in
          . $errors_out
          ;
  }
  
  print $errors_in  if $flags->{verbose_in } and scalar @errors_in  > 0;
  print $errors_out if $flags->{verbose_out} and scalar @errors_out > 0;



  return \@errors_in, \@errors_out;
}




######################################################### GET NAMED EXECUTABLE
sub Get_Exe { 
  my $name = $_[0];
  my $flag = $_[1];

  if ( not defined $name or not $name ) { 
    return;
  }

  if ( -e $name ) {
    return $name;
  }

  #my $prog = `which $name`;
  #chomp $prog;
  my $prog = File::Which::which($name);

  return $prog if $prog;

  # TODO: WTF DID I MEAN HERE. It just causes problems so commenting out.
  # Try just the name itself, if passed a directory.
  #my ($path, $dir, $file) = Split_Path($name);
  #if ( $dir and -d $dir ) { 
  #  $prog = File::Which::which($file);
  #  return $prog if $prog;
  #}

  
  # Check if failure is fatal.
  if ( $flag and $flag eq 'fatal' ) { 
    if ( not defined $prog ) { 
      confess "Couldn't fine executable for program $name.\n";
    }
  }

  return $prog;
}


################################################################# REPORT ERROR
# Verbosity levels:
#   0:  Unsupported. You already called a reporting subroutine right?
#   1:  Report simple error message
#   2:  Report STDERR
#   3:  Report STDOUT

our %FLAGS_REPORT_ERROR = (
  write_file  => 0,
  fatal       => 0,
  verbose     => 1,
);

sub Report_Error { 

  my $error  = $_[0];
  my $result = $_[1];
  my $flags  = $_[2] || {};

  my %flags = %FLAGS_REPORT_ERROR;
  Set_Flags($flags, \%flags);  

  my $verbose = Max($flags{verbose}, $flags{verbose_error});

  #=============== Report simple error
  print "\n\n========== ERROR  ==========\n$error\n\n";

  #=============== Format the detailed output
  my $details = "";
  my $everything = "";
  
  #--------------- No detailed explanation besides the error
  if ( not $result ) { $details = "" }

  #--------------- Probably a list of error messages
  elsif ( (ref $result) eq "ARRAY" ) { $details = join "\n\n", @$result }

  #--------------- Structured report from Try Command
  elsif ( (ref $result) eq 'HASH' ) { 
    if ( $result->{try_command_report} ) { 

      print "  $result->{desc}\n"
          . "  $result->{command}\n"
          ;

      my $stdout = "---------- STDOUT ----------\n$result->{out}\n\n";
      my $stderr = "---------- STDERR ----------\n$result->{err}\n\n";
      $everything .= $stdout . $stderr;

      if ( $verbose >= 3 ) { $details .= $stdout }
      if ( $verbose >= 2 ) { $details .= $stderr }
    }
    #------------- Random hash?  WTF?
    else { $details = join "\n\n", each %$result }
  }
  #--------------- Result is the detailed details itself
  else { $details = $result }


  #=============== Report detailed error
  if ( $verbose >= 2 ) { 
    print "$details\n";
  }

  #=============== Write the error file
  if ( $flags->{'write_file'} ) { 
    my $file = uc "ERROR_-_$error\_-_$PID";
    $file =~ s/\s/_/g;
    $file =~ s/[^\w\.]/_/g;
    Utility::Write_File($file, $error . "\n\n" . $everything, 1);
  }

  if ( $flags->{'fatal'} ) { 
    print "This was fatal!\n";
    exit(1);
  }
}





sub Get_RE_Matches { 

  my $string = $_[0];
  my $match  = $_[1];

  my @matches = ( $string =~ m/$match/g ) 
    or carp "Utility::Get_RE_Matches '$string' did not match '$match'.\n";

  if    ( scalar @matches  > 1 ) { return @matches }
  elsif ( scalar @matches == 1 ) { return $matches[0] }
  else                           { return }
}



sub Find_Missing_Level { 
  my ($struct, $level, @args) = @_;

  #print "$level " . (join ',', @args) . "\n";

  if ( scalar @args == 0 ) { 
    #print "Succeeding\n";
    return 0;
  }

  my $failed = 1;
  my $fail_level;
  my $dump;

  if ( ref $struct eq 'ARRAY' ) { 
    if ( defined $struct->[$args[0]] ) { 
      ($failed, $fail_level, $dump) 
        = Find_Missing_Level($struct->[$args[0]], $level+1, @args[1..$#args]);
    }
  } elsif ( ref $struct eq 'HASH' ) { 
    if ( defined $struct->{$args[0]} ) { 
      ($failed, $fail_level, $dump) 
        = Find_Missing_Level($struct->{$args[0]}, $level+1, @args[1..$#args]);
    }
  } else { 
    # Go back one level cuz we got to a leaf somehow.
    #print "Failing\n";
    return 1, $level;
  }

  if ( $failed ) { 
    if ( not $dump ) { 
      $Data::Dumper::Maxdepth=2;
      $dump = Dumper($struct);
    }
    if ( not defined $fail_level ) { 
      $fail_level = $level;
    }

    if ( $level == 0 ) { 
      confess "Found missing level at argument $fail_level.\n"
            . "Args: " . (join ', ', @args) . "\n"
            . $dump
            ;
    } else { 
      #print "Failing\n";
      return 1, $level, $dump;
    }
  }
}



1;
__END__


