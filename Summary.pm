package Summary;
BEGIN{ 
  push @INC, "/users/scouras/code/summary/", 
             "/users/scouras/code/scouras/", 
             "/Users/scouras/lab/code/summary/", 
             "/Users/scouras/lab/code/scouras/",
             ;
}

#use 5.008006;
use strict;
use warnings;
use Carp;
use Data::Dumper;
require Exporter;
use Math::Trig;
use Utility;

# CVS VERSION INFORMATION (AUTOMAGICALLY GENERATED BY CVS)
'$Revision: 1.7 $'              =~ /^.Revision: (.*) \$/; our $VERSION    = $1;
'$Date: 2009/03/03 19:32:38 $'  =~ /^.Date: (.*) \$/;     our $CHECKED_IN = $1;
'$Author: scouras $'            =~ /^.Author: (.*) \$/;   our $AUTHOR     = $1;


our @ISA = qw(Exporter);

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows the declaration: use Summary ':all';
# If you do not need this, moving things directly into @EXPORT or @EXPORT_OK
# will save memory.
our %EXPORT_TAGS = ( 'all' => [ qw(
  $Summary_File
  $Summary_Dir
  $Group_File
  $Group_Diffs_File
  $Transpose
  $Summarize_Group
  $Summarize_Simulation
  $Correlation_Matrix
  @Analyses
  @Need_Stats

  %DSSP_Match
  @SASA_Columns
  @SASA_Reported
  %SASA_Lookup
  @SASA_Reported_Columns
  %MCGEO_File_Map

  &Read_Configuration_File
  &Read_Summary_File
  &Check_Cache_for_Elements
  &Backup_File_With_Date
  &Block_Data_File
  &Get_Element_Correlations

  &Get_Residue_Indecies


  $Alpha
  $Beta
  $Angstrom
  %Plot_Parameters
  &Translate_LAS
  &Translate_PADJ
  &Translate_Legend_Orientation


) ] );

our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

our @EXPORT = qw();




############################################## STANDARD PARAMETERS

#===== Summary File for Output
our $Summary_File     = "summary.dat";
our $Summary_Dir      = "summary";
our $Group_File       = "group";
our $Group_Diffs_File = "group_diffs";

#===== Simulation Summary Program
our $Root;
if    ( -e "/users/scouras/code/summary"     ) { $Root = "/users/scouras/code" }
elsif ( -e "/Users/scouras/phd/code/summary" ) { $Root = "/Users/scouras/lab/code" }
#elsif ( -e "/Users/scouras/lab/code/summary" ) { $Root = "/Users/scouras/lab/code" }
else { die "Couldn't find root directory" }
our $Transpose            = "$Root/scouras/transpose";
our $Summarize_Group      = "$Root/summary/summarize_group";
our $Summarize_Simulation = "$Root/summary/summarize_simulation";
our $Correlation_Matrix   = "$Root/scouras/plot_correlation_matrix";

#===== Analysis List

my @Analyses = qw(dssp rmsd rmsf_t mcgeo sasa);

#===== Statistics that we currently expect

our @Need_Stats = qw(MIN MAX MEAN SD);
our @FDSA_Types = qw(all charged hbonds hphobes other);

################################################ ANALYSIS PARAMETERS

#===== RMSD

our $RMSD_Column = 1;

#===== DSSP

our %DSSP_Match = ( 
  helix         => "[GHI]", 
  ahelix        => "[H]",
  phelix        => "[I]",
  thelix        => "[G]",
  
  sheet         => "[aAbBcC]", 
  bridge        => "[rRsS]", 
  abridge       => "[rR]",
  bbridge       => "[sS]",
  asheetonly    => "[aA]",
  bsheetonly    => "[bB]",
  sheet         => "[aAbBcCrRsS]",
  asheet        => "[aArR]",
  bsheet        => "[bBsS]",
);

#===== SASA

our @SASA_Columns = qw(
  main-chain 
  side-chain 
  polar 
  non-polar 
  mc-polar 
  mc-non-polar 
  sc-polar 
  sc-non-polar 
  total
);

our @SASA_Reported = qw(
  main-chain 
  side-chain 
  total
);

our %SASA_Lookup = ();
foreach my $i ( 0..$#SASA_Columns ) { 
  $SASA_Lookup{$SASA_Columns[$i]} = $i+1;
}
our @SASA_Reported_Columns = map { $SASA_Lookup{lc $_} } @SASA_Reported;



our %MCGEO_File_Map = (
  cacaca  => 'mcgeo_CaCaCa_angle.dat',
  ccc     => 'mcgeo_CCC_angle.dat',
  ooo     => 'mcgeo_OOO_angle.dat',
  coco    => 'mcgeo_COCO_angle.dat',
  hhh     => 'mcgeo_HHH_angle.dat',
  nnn     => 'mcgeo_NNN_angle.dat',

  ca1     => 'mcgeo_CaCa_dist_1.dat',
  ca2     => 'mcgeo_CaCa_dist_2.dat',
  ca3     => 'mcgeo_CaCa_dist_3.dat',
  ca4     => 'mcgeo_CaCa_dist_4.dat',
  ca5     => 'mcgeo_CaCa_dist_5.dat',
  ca6     => 'mcgeo_CaCa_dist_6.dat',
  ca7     => 'mcgeo_CaCa_dist_7.dat',

  hh      => 'mcgeo_HH_distance.dat',
  ho      => 'mcgeo_HO_distance.dat',
  oh      => 'mcgeo_OH_distance.dat',
  oo      => 'mcgeo_OO_distance.dat',
);



################################################# LOAD CONFIGURATION

sub Read_Configuration_File { 

  my $config_file = $_[0] 
    or confess "Summary::Read_Configuration_File: You must pass a configuration file";

  if ( not -e $config_file ) { 
    confess "Summary::Read_Configuration_File: Configuration file '$config_file' does not exist";
  }
  my @config_lines = split "\n", `cat $config_file`;
  
  my $include_list = $_[1];
  my $exclude_list = $_[2];
  my @include_list;
  my @exclude_list;

  #======== Get Filters
  if ( defined $include_list ) {
    if ( ref $include_list eq 'ARRAY' ) { @include_list = @$include_list  }
    else                                { @include_list = ($include_list) }
  }
  if ( defined $exclude_list ) {
    if ( ref $exclude_list eq 'ARRAY' ) { @exclude_list = @$exclude_list  }
    else                                { @exclude_list = ($exclude_list) }
  }
  
  my @config_exclude = Fetch_Argument ('sim_exclude', \@config_lines );
  push @exclude_list, split ',', $_ foreach @config_exclude;
  if ( scalar @exclude_list > 0 ) { 
    print "Using exclusion list: " . (join ', ', @exclude_list) . "\n";
  }

  #======== Simulation Directories
  my @sim_globs = Fetch_Argument ('simulations', \@config_lines, 1);
  my @sim_dirs = ();
  foreach my $glob ( @sim_globs ) { 
    print "Testing sim glob '$glob'\n";
    my @dirs = grep { -d }  glob($glob);
    if ( scalar @dirs == 0 ) { 
      print "Simulations glob did not match any simulations: '$glob'.\n";
      next;
    }
    
    #==== Test each directory for inclusion/exclusion
    foreach my $dir ( @dirs ) { 

      #---- Inclusion Filters
      if ( scalar @include_list ) { 
        my $is_included = 0;
        foreach my $inc ( @include_list ) { 
          if ( $dir =~ /$inc/i ) { 
            $is_included = 1;
            last;
          }
        }
        next if not $is_included
      }

      #----- Exclusion Filters
      if ( scalar @exclude_list ) { 
        my $is_excluded = 0;
        foreach my $exc ( @exclude_list ) { 
          if ( $dir =~ /$exc/i ) { 
            $is_excluded = 1;
            last;
          }
        }
        next if $is_excluded;
      }
    
      print "Adding simulation: '$dir'\n";
      push @sim_dirs, $dir;
    }
  }
  @sim_dirs = sort @sim_dirs;

  if ( scalar @sim_dirs == 0 ) { 
    die "Simulations globs did not match any simulations.\n";
  }
  #print "Added " . scalar @sim_dirs . " simulations\n";


  #======== Simulation Groups

  my @sim_group_lines = Fetch_Argument ('sim_group', \@config_lines);
  my %sim_group_tags = ();
  my @sim_group_list = ();
  foreach my $group ( @sim_group_lines ) { 
    my ( $title, $tags ) = split /\s+/, $group;
    if ( not $title or not $tags ) { confess "Misformed sim_group line, '$group'" }

    my @tags = split /,\s*/, $tags;
    push @sim_group_list, {
      title => $title,
      tags => \@tags,
    };

    foreach my $tag ( @tags ) { 
      $sim_group_tags{$title}{$tag} = [];
      foreach my $dir ( @sim_dirs ) { 
        if ( $dir =~ /$tag/ ) { push @{$sim_group_tags{$title}{$tag}}, $dir }
      }
    }
  }

  #======== Repository

  my $repository   = Fetch_Argument('repository', \@config_lines, 1, 1);
  my $repo_sims    = "$repository/simulations";
  my $repo_elems   = "$repository/elements";
  my $repo_elems_t = "$repository/elements_transposed";
  my $repo_corrs   = "$repository/correlations";
  foreach my $repo ( $repository, $repo_sims, $repo_elems, $repo_elems_t, $repo_corrs ) { 
    if ( not -e $repo ) { 
      print "Creating repository directory '$repo'.\n";
      mkdir $repo or confess "Couldn't make repository, '$repo'. $!";
    } elsif ( not -d $repo ) { 
      print "Repository ($repo) exists but is not a directory.\n";
      exit;
    }
  }

  #======== Resolution

  my $resolution = Fetch_Argument('resolution', \@config_lines, 1, 1);
  if ( not Utility::Is_Positive_Integer($resolution) ) { 
    print "Resolution ($resolution) must be a positive integer (resolution in picoseconds).\n";
    exit;
  }
 
  #======== Simulation Type
  my $sim_type = Fetch_Argument('sim_type', \@config_lines, 1, 1);

  #======== Simulation Time
  my $sim_time = Fetch_Argument('sim_time', \@config_lines, 1, 1);
  if ( not Utility::Is_Positive_Integer($sim_time) ) { 
    confess "Simulation time ($sim_time) must be a positivie integer (the duration in picoseconds).";
  }

#  #======== Offsets
#
#  my @offsets = Fetch_Argument('offset', \@config_lines);
#  my %offsets = ();
#  foreach my $line ( @offsets ) { 
#    my ( $tag, $offset ) = split /\s+/, $line;
#    if ( not Utility::Is_Integer($offset) ) { 
#      confess "Offsets must be an integer ($tag, $offset).\n";
#    }
#    $offsets{$tag} = $offset;
#  }


  #======== Sequence Map File

  my $seq_map_file = Fetch_Argument("sequence_map_file", \@config_lines, 1, 1);
  my $seq_map = Utility::Parse_Sequence_File($seq_map_file);
  my $seq_map_species = Fetch_Argument("sequence_map_species", \@config_lines, 1, 1);


  #======== Time Blocks
  my $time_block = Fetch_Argument('time_block', \@config_lines, 0, 1);
  my ($time_block_start, $time_block_end);
  if ( defined $time_block ) { 
    ($time_block_start, $time_block_end) = split '-', $time_block;
  }


  #========== Regions
  my @regions = Fetch_Argument('region', \@config_lines);
  my %regions = ();
  foreach my $r ( @regions ) { 
    my ( $title, $res ) = split /\s+/, $r;
    my @res = Parse_Residue_Range ( $res, \%regions );
    $regions{$title} = { str=>$res, res=>\@res };
    print "REGION: $title\tSTR: $res\n";
  }
  
  #======== Analysis Residue Groups

  my @anal_lines = (
    (grep { /^sasa/  } @config_lines),
    (grep { /^dssp/  } @config_lines), 
    (grep { /^mcgeo/ } @config_lines), 
    (grep { /^rmsd/  } @config_lines), 
    (grep { /^rmsf_t/} @config_lines), 
    (grep { /^fdsa/  } @config_lines), 
  );

  my @residue_groups = ();
  my @residue_group_lines = grep { /^resgroup/ } @config_lines;
  foreach my $line ( @residue_group_lines ) { 
    my ($res_group, $res_range) = split /\s+/, $line;
    $res_group =~ /^resgroup_(.*)/
      or confess "Couldn't parse residue group element: '$line'.";
    my $elem = $1;

    my @res = Parse_Residue_Range ( $res_range, \%regions );
    push @anal_lines, "$elem $res_range";
    foreach my $res ( @res ) { 
      #my $sprint_res = sprintf "%04u", $res;
      #push @anal_lines, "$elem$sprint_res $res";
      push @anal_lines, "$elem-res$res $res";
    }
    push @residue_groups, {
      elem      => $elem,
      res_range => $res_range,
      residues  => \@res,
    };
  }


  #======== Analysis Elements


  my %elements = ();
  $elements{'fdsa'  } = Parse_FDSA_Lines  ( \@anal_lines, \%regions );
  $elements{'rmsd'  } = Parse_RMSD_Lines  ( \@anal_lines, \%regions );
  $elements{'rmsf_t'} = Parse_RMSF_T_Lines( \@anal_lines, \%regions );
  $elements{'sasa'  } = Parse_SASA_Lines  ( \@anal_lines, \%regions );
  $elements{'dssp'  } = Parse_DSSP_Lines  ( \@anal_lines, \%regions );
  $elements{'mcgeo' } = Parse_MCGEO_Lines ( \@anal_lines, \%regions );
  $elements{'all'   } = {};
  
  
  my @elements_list = ();
  
  foreach my $anal ( @Analyses ) { 
    foreach my $e ( keys %{$elements{$anal}} ) {
      my $elem = $elements{$anal}{$e};
      $elements{'all'}{$e} = $elem;
      push @elements_list, $e;
    }
  }

  @elements_list = sort {Sort_Elements($a, $b)} @elements_list;

  #if ( not scalar @elements_list ) { 
  #  confess "Summary::Read_Configuration_File: Did not find any elements in file, '$config_file'";
  #}

  #======== Return Configuration Hash

  my %config = (
    config_lines    => \@config_lines,
    sim_globs       => \@sim_globs,
    sim_dirs        => \@sim_dirs,
    sim_group_tags  => \%sim_group_tags,
    sim_group_list  => \@sim_group_list,
    sim_time        => $sim_time,
    repository      => $repository,
    repo_sims       => $repo_sims,
    repo_elems      => $repo_elems,
    repo_corrs      => $repo_corrs,
    resolution      => $resolution,
    simulation_type => $sim_type,
    #offsets         => \%offsets,
    seq_map         => $seq_map,
    seq_map_species => $seq_map_species,
    time_block_start=> $time_block_start,
    time_block_end  => $time_block_end,
    anal_lines      => \@anal_lines,
    residue_groups  => \@residue_groups,
    elements        => \%elements,
    elements_list   => \@elements_list,
  );

  if ( wantarray ) { return  %config }
  else             { return \%config }
}


############################################## FETCH ARGUMENT

sub Fetch_Argument { 
  my $name  = $_[0];
  my $lines = $_[1];
  my $min   = $_[2];
  my $max   = $_[3];

  #print Dumper ($name);
  #print Dumper ($lines);
  my @args = map { /^$name\s+(.*)$/; $1 } grep { /^$name\s/ } @$lines;


  my $count = scalar @args;
  if ( defined $min and $count < $min ) { 
    confess "Summary::Fetch_Argument: Too few arguments for '$name' in config file. Min: $min  Found: $count\n"
      . "  " . (join ',', @args) . ")";
  }
  if ( defined $max and $count > $max ) { 
    confess "Summary::Fetch_Argument: Too many arguments for '$name' in config file. Max: $max  Found; $count\n"
      . "  " . (join ',', @args) . ")";
  }
  if ( defined $max and $max == 1 ) { return $args[0] || undef }
  if ( wantarray ) { return  @args }
  else             { return \@args }
}


########################################### READ SUMMARY FILE

sub Read_Summary_File { 

  my $cache_file = $_[0] 
    or confess "Summary::Read_Summary_File: No cache file passed.\n";

  if ( not -e $cache_file ) { 
    confess "Summary::Read_Summary_File: Cache file ($cache_file) not found.\n";
  }

  my @need_stats = (defined $_[1] ? @{$_[1]} : ());
  my @need_times = (defined $_[2] ? sort { $a <=> $b } @{$_[2]} : ());
  my @need_elems = (defined $_[3] ? @{$_[3]} : ());

  my %CACHE = ();
  my @CACHE = map { [split /\s+/, $_] } split /\n/, `cat $cache_file`;
  
  if ( scalar @CACHE == 0 ) { 
    print "Cache File ($cache_file) is empty";
    return 0, [], {};
  }

  my @HEADERS = @{$CACHE[0]};
  shift @CACHE;



  #===== Read the cache
  foreach my $h (1..$#HEADERS) { 
    my $header = $HEADERS[$h];
    my $step = 0;
    foreach my $i ( 0..$#CACHE ) { 
      my $cache = $CACHE[$i];
      my $time = $cache->[0];
      if ( $time =~ /^\d+$/ ) { 
        #my $step = POSIX::floor($time/$resolution);
        $CACHE{$header}{'TIMES'}[$step] = $cache->[$h];
        $step++;
      } else { 
        #print "Readinger header $header $time $cache->[$h]\n";
        $CACHE{$header}{$time} = $cache->[$h];
      }
    }
  }


  # Validate the cache
  my @ROWS = map { s/#//g; $_ } map { $CACHE[$_][0] } 0..$#CACHE;
  my @STATS = grep { not /^\d+$/ } @ROWS;
  my @TIMES = sort { $a <=> $b } grep { /^\d+$/ } @ROWS;


  # Check steps
  if ( @need_stats ) { 
    for my $stat ( @need_stats ) { 
      if ( not grep { /$stat/i } @STATS ) { 
        print "Cache is bad.  Missing stat $stat.\n";
        return 0, \@TIMES, \%CACHE;
      }
    }
  }

  # Check timepoints
  if ( @need_times ) {
    foreach my $timepoint (@need_times ) { 
      if ( not grep { $_ eq $timepoint } @TIMES ) { 
        print "Cache is bad.  Missing timepoint $timepoint.\n";
        return 0, \@TIMES, \%CACHE;
      }
    }
  }

  # Check elements
  my $valid = Check_Cache_for_Elements ( \%CACHE, \@need_elems );
  
  # All clear
  return ( 1, \@TIMES, \%CACHE, $valid );
}



######################################### FILTER DATA FOR TIME RANGE

sub Filter_Data_For_Time_Range { 

  my $data  = $_[0];
  my $times = $_[1];
  my $start = $_[2];
  my $end   = $_[3];

  my %new_data = ();

  foreach my $e ( keys %$data ) { 
    my @new_times = ();
    foreach my $i ( 0..$#{$data->{$e}{'TIMES'}} ) { 
      my $t = $times->[$i];
      next if $t < $start or $t > $end;
      push @new_times, $data->{$e}{'TIMES'}[$i];
    }

   ($new_data{$e}{'MEAN' }, $new_data{$e}{'SD'}) = Utility::Mean_and_Stddev ( \@new_times );
    $new_data{$e}{'MIN'  } = Utility::Min ( \@new_times );
    $new_data{$e}{'MAX'  } = Utility::Max ( \@new_times );
    $new_data{$e}{'TIMES'} = \@new_times;
  }
  if ( wantarray ) { return  %new_data }
  else             { return \%new_data }
}



################################################ BACKUP SUMMARY FILE

sub Backup_File_With_Date {
  my $file = $_[0];
  return if not -e $file;

  #===== Get File Modification Time
  my $age  = -M $file;
  my $date = time - $age;

  #===== Don't backup if file is relatively new (i.e. today)
  if ( $age < 60*60*24 ) { return $file }

  #===== Date format is YYYY-MM-DD
  my $str = POSIX::strftime ("%F", localtime ($date));
  my $new = $file . $str;

  #===== If that file already exists, diff them to see if same
  my @suffixes = ("", map { ".$_" } 1..1000);
  foreach my $s ( @suffixes ) { 
    my $new_s = $file . $s;
    if ( -e $new_s ) { 
      my $diff = `diff --brief $file $new_s`;
      if ( not $diff ) { return $new_s }
    } else { 
      `cp $file $new_s`;
      return $new_s;
    }
  }
  confess "Could not fine new name for file $file";
}




############################################ ANALYZE SIMULATION TIME

sub Analyze_Simulation_Time {

  my $dir         = $_[0] or confess "Summary::Analyze_Simulation_Time: Need dir to analyze.\n";
  my $resolution  = $_[1] or confess "Summary::Analyze_Simulation_Time: No resolution passed.\n";
  my $start       = $_[2];
  my $end         = $_[3];

  if ( not -e $dir or not -d $dir ) { 
    confess "Summary::Analyze_Simulation_Time: Was not passed an existing directory, '$dir'.\n";
  }

  my @mdrs = sort { $a cmp $b } glob("$dir/[0-9]*ps.mdr");
  if ( not scalar @mdrs ) { 
    confess "Summary::Analyze_Simulation_Time: Could not find mdrs in dir, '$dir'.\n";
  }

  my $final_mdr = $mdrs[-1];
  $final_mdr =~ /\b(\d+)ps.mdr$/ 
    or confess "Couldn't parse mdr file $final_mdr.\n";
  my $needed_time = $1;

  if ( not defined $start ) { $start = 0 }
  if ( defined $end and $needed_time > $end  ) { $needed_time = $end }

  my @times = ();
  for ( my $i = $end; $i < $needed_time; $i+=$resolution ) { 
    push @times, $i;
  }

  if ( wantarray ) { return  @times }
  else             { return \@times }
}


########################################### CHECK CACHE FOR ELEMENTS

sub Check_Cache_for_Elements { 

  my $cache = $_[0] or confess "Cache not passed in";
  my $list  = $_[1] or confess "Element list not passed";
  my $force = $_[2] || 0;

  my @in_cache  = sort keys %$cache;
  my %in_cache  = map { $_ => 1 } @in_cache;
  my @todo      = grep { not exists $in_cache{$_} or $force } @$list;
  my @cached    = grep {     exists $in_cache{$_} and not $force } @$list;
  my @extra     = Utility::Difference ( \@in_cache, $list );
  my @ignored   = Utility::Intersection ( \@in_cache, \@todo );

  my %valid = (
    total     => \@in_cache,
    todo      => \@todo,
    cached    => \@cached,
    extra     => \@extra,
    ignored   => \@ignored,
    complete  => ((scalar @todo) == 0),
  );

  if ( wantarray ) { return  %valid }
  else             { return \%valid }
}




############################################ CONFIGURATION FILE PARSER HELPERS
# Each function parses a specific set of lines from the configuration file
# necessary to process each analysis.


#======== SASA

sub Parse_SASA_Lines {
  my @lines = (grep { /^sasa/ } @{$_[0]}) or return;
  my $regions = $_[1];
  my %elems = ();
  foreach my $line ( @lines ) { 
    my ($e, $res) = split /\s+/, $line;
    if ( exists $elems{$e} ) { 
      confess "Summary::Parse_SASA_Lines: Repeated element $e:\n  $elems{$e}{'line'}\n  $line\n";
    }
    $e =~ /^sasa_([\w\-]+)_([\w\-]+)$/
      or confess "Couldn't parse sasa element, '$line'";
    my ( $area, $title ) = ($1, $2);
    my @res = Parse_Residue_Range ( $res, $regions );
    my $column = $SASA_Lookup{$area}
      or confess "Couldn't figure out what sasa column corresponded to area, '$area'";
    $elems{$e} = { line => $line, e => $e, area => $area, title => $title, residues => \@res, column => $column };
  }
  if ( wantarray ) { return  %elems }
  else             { return \%elems }
}

#======== DSSP

sub Parse_DSSP_Lines {
  my @lines = (grep { /^dssp/ } @{$_[0]}) or return;
  my $regions = $_[1];
  my %elems = ();
  foreach my $line ( @lines ) { 
    my ($e, $res) = split /\s+/, $line;
    if ( exists $elems{$e} ) { 
      confess "Summary::Parse_DSSP_Lines: Repeated element $e:\n  $elems{$e}{'line'}\n  $line\n";
    }
    $e =~ /^dssp_([\w\-]+)_([\w\-]+)$/
      or confess "Couldn't parse dssp element, '$line'.";
    my ( $ss, $title ) = ($1, $2);
    my @res = Parse_Residue_Range ( $res, $regions );
    my $match = $DSSP_Match{$ss} 
      or confess "Couldn't find DSSP match for element '$ss'.";
    $elems{$e} = { line => $line, e => $e, ss => $ss, title => $title, residues => \@res, match => $match };
  }

  if ( wantarray ) { return  %elems }
  else             { return \%elems }
}

#======== MCGEO

sub Parse_MCGEO_Lines {
  my @lines = (grep { /^mcgeo/ } @{$_[0]}) or return;
  my $regions = $_[1];
  my %elems = ();
  foreach my $line ( @lines ) { 
    my ($e, $res) = split /\s+/, $line;
    if ( exists $elems{$e} ) { 
      confess "Summary::Parse_MCGEO_Lines: Repeated element $e:\n  $elems{$e}{'line'}\n  $line\n";
    }
    $e =~ /^mcgeo_([^_]+)_([^_]+)_([^_]+)$/
      or confess "Couldn't parse mcgeo element, '$line'.";
    my ( $geo, $stat, $title ) = ($1, $2, $3);
    my @res = Parse_Residue_Range ( $res, $regions );
    $elems{$e} = { line=>$line, e=>$e, geo=>$geo, stat=>$stat, title=>$title, residues=>\@res };
  }
  if ( wantarray ) { return  %elems }
  else             { return \%elems }
}

#======== RMSF_T

sub Parse_RMSF_T_Lines {

  my @lines = (grep { /^rmsf_t/ } @{$_[0]}) or return;
  my $regions = $_[1];
  my %elems = ();
  foreach my $line ( @lines ) { 
    my ($e, $res) = split /\s+/, $line;
    if ( exists $elems{$e} ) { 
      confess "Summary::Parse_RMSF_T_Lines: Repeated element $e:\n  $elems{$e}{'line'}\n  $line\n";
    }
    
    $e =~ /^rmsf_t_(.+)_(.*)$/
      or confess "Couldn't parse rmsf_t element, '$line'.";
      my ( $region, $title ) = ( $1, $2 );
    
    my $dir = "rmsd_$region";
    my @res = Parse_Residue_Range ( $res, $regions );
    $elems{$e} = { line=>$line, e=>$e, title=>$title, dir=>$dir, region=>$region, residues=>\@res };
  }
  if ( wantarray ) { return  %elems }
  else             { return \%elems }
}

#======== RMSD

sub Parse_RMSD_Lines {

  my @lines = (grep { /^rmsd/ } @{$_[0]}) or return;
  my $regions = $_[1];
  my %elems = ();
  foreach my $line ( @lines ) { 
    my ($e, $res) = split /\s+/, $line;
    if ( exists $elems{$e} ) { 
      confess "Summary::Parse_RMSD_Lines: Repeated element $e:\n  $elems{$e}{'line'}\n  $line\n";
    }
    if ( $e =~ /^rmsd$/ ) { 
      $elems{$e} = { line => $line, e => $e, dir => 'rmsd', region => 'whole' };
    } elsif ( $e =~ /^rmsd_(.+)$/ ) {
      $elems{$e} = { line => $line, e => $e, dir => $e, region => $1 }
    } else {
      confess "Couldn't parse rmsd element, '$line'.\n";
    }
  }
  if ( wantarray ) { return  %elems }
  else             { return \%elems }
}

#========= FDSA

sub Parse_FDSA_Lines { 

  my @lines = (grep { /^fdsa/ } @{$_[0]}) or return;
  my $regions = $_[1];
  my %elems = ();
  foreach my $line ( @lines ) { 
    my ( $e, $r1, $a1, $r2, $a2, $types ) = split /\s+/, $line;
    if ( exists $elems{$e} ) { 
      confess "Repeated element $e:\n $elems{$e}{'line'}\n $line\n";
    }
    $a1 = uc $a1;
    $a2 = uc $a2;
    if ( $a1 ne 'ALL' and $a1 ne 'SC' and $a1 ne 'MC' ) { die "FDSA element $e must specify atom types ALL, SC, or MC\n$line\n"; }
    if ( $a2 ne 'ALL' and $a2 ne 'SC' and $a2 ne 'MC' ) { die "FDSA element $e must specify atom types ALL, SC, or MC\n$line\n"; }

    my ($f, $title) = split '_', $e;
    my @r1 = Parse_Residue_Range ( $r1, $regions );
    my @r2 = Parse_Residue_Range ( $r2, $regions );
    $types ||= 'all';
    my @types = split ',', $types;

    $elems{$e} = { line=>$line, e=>$e, r1=>\@r1, a1=>$a1, r2=>\@r2, a2=>$a2, types=>\@types };
  }
  if ( wantarray ) { return  %elems }
  else             { return \%elems }
}



################################################## NORMALIZE ELEMENT

sub Normalize_Element { 
  my $data    = $_[0];
  my $counts  = $_[1];
  my $steps   = $_[2];
  my $times   = $data->{'TIMES'};
  foreach my $step ( 0..$steps-1 ) { 
    next if not $counts->[$step];
    $times->[$_] /= $counts->[$_];
  }
}



################################################### FINALIZE ELEMENT

sub Finalize_Element { 
  my $data   = $_[0];
  my $time   = $data->{'TIMES'};
  $data->{'MIN'} = Utility::Min($time);
  $data->{'MAX'} = Utility::Max($time);
  ($data->{'MEAN'}, $data->{'SD'}) = Utility::Mean_and_Stddev($time);
}


################################################### BLOCK DATA FILE

sub Block_Data_File {

  my $file    = $_[0];
  my $size    = $_[1];
  my $columns = $_[2];

  my @min;
  my @max;
  my @mean    = ();
  my @sd      = ();
  my @blocks  = ();
  my @counts  = ();
  my @headers = ();

  my $width;

  my $line;

  #print "Opening data file, '$file'.\n";
  my $FH = Utility::Open_File ( $file );

  ##### Collect Data
  while ( defined ( $line = <$FH> ) ) { 
    $line = Utility::Trim ( $line );
    my @line = split /\s+/, $line;
    
    # Get Header
    if ( $line =~ /^#/ ) { 
      $line =~ s/#\s*//g;
      @headers = split /\s+/, $line;
      next;
    }
    
    my $time = $line[0];
    next if not defined $time;
    if ( not $time =~ /^[\d\.]+$/ ) 
      { confess "Summary::Block_Data_File: time is not a number, '$time'" }
    my $step = POSIX::floor($time/$size);
    if ( not defined $width ) { $width = scalar @line }
    if ( not defined $columns ) { $columns = [1..($width-1)] }

    $blocks[$step][0] = $time;
    $counts[$step]++;
    foreach my $i ( @$columns ) { 
      my $d = $line[$i];
      if ( not defined ($min[$i]) or $d < $min[$i] ) { $min[$i] = $d }
      if ( not defined ($max[$i]) or $d > $max[$i] ) { $max[$i] = $d }
      $mean[$i] += $d;
      $blocks[$step][$i] += $d;
    }
  }

  close $FH or confess "Couldn't close file, '$file'. $!";

  ##### Normalize Blocks
  foreach my $step ( 0..$#blocks ) { 
    my $datum = $blocks[$step];
    my $count = $counts[$step];
    foreach my $i ( @$columns ) { 
      if ( $count ) { $datum->[$i] /= $count } 
      else          { $datum->[$i] = 0 }
    }
  }

  my $count = Utility::Sum( \@counts );
  ##### Normalize Globals
  foreach my $i ( @$columns ) { 
    $mean[$i] /= $count;
  }

  ##### Return Data
  return ( \@min, \@max, \@mean, \@sd, \@counts, \@blocks, \@headers );

}





########################################### GET ELEMENT CORRELATIONS

sub Get_Element_Correlations { 

  my $dir   = $_[0];
  my $title = $_[1];
  my $base  = $_[2];
  my $data  = $_[3];
  my $force = $_[4];

  my $MIN_CORRELATION = 0.8;
  my $MIN_CORRELATED_COUNT = 3;

  my @elems = sort { Sort_Elements($a,$b) } keys %$data;
  my @vary  = grep { $data->{$_}{'SD'} > 0.001 } @elems;

  if ( not scalar @vary ) { 
    print "Correlation data in $dir $title is all non varying.\n";
    return;
  }

  #my $base   = lc Utility::Clean_Filename ( $title );
  my $raw    = "$dir/$base.corr.raw";
  my $log    = "$dir/$base.corr.log";

  #===== CHECKING CACHE DATA
  # Check for missing elements in existing correlation files
  my $cache_good = 1;
  if ( -e $raw ) { 
    my @headers = split /\s+/, `head -n 1 $raw`;
    foreach my $e ( @vary ) { 
      if ( not grep { $e } @headers ) { 
        $cache_good = 0;
        last;
      }
    }
  }

  if    ( not -e "$raw.corr.matrix.dat"             ) { $cache_good = 0 }
  elsif ( not -e "$raw.corr.list.dat"               ) { $cache_good = 0 }
  elsif ( not -e "$raw.cross.heatmap.complete.png"  ) { $cache_good = 0 }
  return if $cache_good;

  open OUT, ">$raw" or die "Couldn't open correlation data file, '$raw'. $!";
  print OUT (join "\t", @vary) . "\n";
  foreach my $step ( 0..($#{$data->{$vary[0]}{'TIMES'}} ) ) { 
    print OUT (
            join "\t", 
              map { $data->{$_}{'TIMES'}[$step] || $data->{$_}{'TIMES'}[$step-1] || 0 } @vary 
          ) . "\n";
  }
  close OUT or die "Couldn't close correlation data file, '$raw'. $!";


  my $cmd = "$Correlation_Matrix $raw -title='$title' -base='$base' -mincorr=$MIN_CORRELATION -mincount=$MIN_CORRELATED_COUNT 2>&1";
  #print "$cmd_corr\n";
  my $result = `$cmd`;

  open LOG, ">$log" or die "Couldn't open correlation log file, '$log'. $!";
  print LOG $result;
  close LOG or die "Couldn't close correlation log file, '$log'. $!";

}




################################################ FILTER CORRELATIONS















#################################################### PARSE DIRECTORY

sub Parse_Directory {

  my $type = $_[0];
  my $dir  = $_[1];

  #===== Compressed Prion Simulations
  if ( $type eq 'prion_compressed' ) { 
    $dir =~ /\/(\w+)__(\d+)-(\d+)__(\w+)__(\w+)__\w+__(\d\d\d)__(\d)$/;
    my ($start, $finish) = ($2, $3);
    my $parse = { 
      tags            => [qw(species fragment mutant ph temp run)],
      dir             => $dir,
      species         => $1,
      fragment        => "$2-$3",
      mutant          => $4,
      ph              => $5,
      temp            => $6,
      run             => $7,
      start_residue   => $start,
      finish_residue  => $finish,
    };
    $parse->{'title'} = ( ucfirst lc $parse->{'species'  } ) . ' - '    
                      . (            $parse->{'fragment' } ) . ' - '    
                      . (         uc $parse->{'mutant'   } ) . ' - '    
                      . (    ucfirst $parse->{'ph'       } ) . ' pH - ' 
                      . (            $parse->{'temp'     } ) . 'K - '   
                      . (            $parse->{'run'      } )
                      ;
    $parse->{'file'} = lc $parse->{'title'};
    $parse->{'file'} =~ s/ /_/g;
    $parse->{'file'} =~ s/_-_/-/g;

    return $parse;
  }

  #===== Normal Prion Simulations
  if ( $type eq 'prion' ) { 
    $dir =~ /cscale_1_3_0.4\/(\w+)\/(\w+-\w+)\/(\w+)\/(\w+)\b.*\b(\d\d\d)\/(\d)$/
      or confess "Couldn't parse directory, '$dir'.";

    my ($start, $finish) = split '-', $2;
    my $parse = { 
      tags            => [qw(species fragment mutant ph temp run)],
      dir             => $dir,
      species         => $1,
      fragment        => $2,
      mutant          => $3,
      ph              => $4,
      temp            => $5,
      run             => $6,
      start_residue   => $start,
      finish_residue  => $finish,
    };
    $parse->{'title'} = ( ucfirst lc $parse->{'species'  } ) . ' - '    
                      . (            $parse->{'fragment' } ) . ' - '    
                      . (         uc $parse->{'mutant'   } ) . ' - '    
                      . (    ucfirst $parse->{'ph'       } ) . ' pH - ' 
                      . (            $parse->{'temp'     } ) . 'K - '   
                      . (            $parse->{'run'      } )
                      ;
    $parse->{'file'} = lc $parse->{'title'};
    $parse->{'file'} =~ s/ /_/g;
    $parse->{'file'} =~ s/_-_/-/g;
    return $parse;
  }
}


sub Parse_Residue_Range { 

  my $range = $_[0];
  my $regions = $_[1];

  my %regions;
  if ( ref $regions eq 'HASH' ) { 
    %regions = %$regions;
  }

  my @range = split ",", $range;
  my @range_str = ();

  foreach my $ran ( @range ) { 
    my $did_sub = 0;
    foreach my $r ( keys %regions ) { 
      if ( $r eq $ran ) { 
        my $str = $regions{$ran}{'str'};
        #print "Subbing $r $str for $range\n";
        push @range_str, $str;
        $did_sub = 1;
        last;
      }
    }
    
    if ( $ran =~ /^\d+$/ or $ran =~ /^\d+-\d+$/ ) { 
      push @range_str, $ran;
      next;
    }

    if ( not $did_sub and $ran =~ /([a-z]+)/ ) { 
      die "Unknown region '$ran' in residue range $range";
    }
  }
  return Utility::Parse_Range ( join ',', @range_str );
}



########################################### CALCULATE RESIDUE OFFSET

sub Calculate_Residue_Offset { 

  my $dir_parse = $_[0] or confess "Summary::Calculate_Offset: No dir parse passed";
  my $offsets   = $_[1] or confess "Summary::Calculate_Offset: No offsets passed";

  my $dir = $dir_parse->{'dir'};
  foreach my $tag ( keys %$offsets ) { 
    if ( $dir =~ /$tag/ ) { 
      return $offsets->{$tag};
    }
  }
  if ( $offsets->{'default'} ) { return $offsets->{'default'}; }
  return;
}
  


#################################### ADJUST RESIDUES BY SEQUENCE MAP

sub Adjust_Residues_by_Sequence_Map { 
  my $map         = $_[0];
  my $start_res   = $_[1];
  my $finish_res  = $_[2];
  my $sp_from     = $_[3];
  my $sp_to       = $_[4];
  my $residues    = $_[5];
  my @idx_real = grep { $_ >= $start_res and $_ <= $finish_res } 
                      Utility::Seq_Translate_Index ( $map, $sp_from, $sp_to, $residues );
  my @idx_1    = map { $_ - $start_res + 1 } @idx_real;
  my @idx_0    = map { $_ - 1 } @idx_1;
  return \@idx_real, \@idx_0, \@idx_1; 
}



########################################## ADJUST RESIDUES BY OFFSET

sub Adjust_Residues_by_Offset {
  my $residues  = $_[0];
  my $offset    = $_[1];
  my $start     = $_[2];
  my $finish    = $_[3];

  my @offsets = ();
  
  foreach my $res ( @$residues ) { 
    my $off = $res + $offset;
    if ( $off < $start  ) { $off = $start  }
    if ( $off > $finish ) { $off = $finish }
    push @offsets, $off;
  }
  @offsets = sort { $a<=>$b } Utility::Unique(@offsets);

  my @res_idx_0 = map { $_ - $start     } @offsets;
  my @res_idx_1 = map { $_ - $start + 1 } @offsets;

  return (\@offsets, \@res_idx_0, \@res_idx_1);
}

###################################################### SORT ELEMENTS
sub Sort_Elements {
  my $a=$_[0]; 
  $a =~ /^(.+?)(\d*)$/
    or confess "Summary::Sort_Elements: Couldn't parse sort element a '$a'";
  my ($a_pre, $a_idx) = ($1, $2);
 
  my $b=$_[1]; 
  $b =~ /^(.+?)(\d*)$/
    or confess "Summary::Sort_Elements: Couldn't parse sort element b '$b'";
  my ($b_pre, $b_idx) = ($1, $2);

  if ( $a_pre ne $b_pre ) { 
    return $a cmp $b;
  } elsif ( not $a_idx ) { 
    return 1;
  } elsif ( not $b_idx ) { 
    return -1;
  } else {
    return $a_idx <=> $b_idx;
  }

#  if ( not defined $a or not defined $b ) { 
#    return $a cmp $b;
#  } elsif ( $a_pre ne $b_pre ) { 
#    return $a cmp $b;
#  } else {
#    print "$a_idx, $b_idx\n";
#    return $a_idx <=> $b_idx;
#  }
}











####################################################################
#                                               PLOTTING SUBROUTINES
####################################################################



##################################### DEFAULT PLOT PARAMETER OPTIONS

our %Plot_Parameters = ( 
  
  screen => {},

  publication => {

    background_color  => 'white',
    image_width       =>  1000,
    image_height      =>   500,
    font_size         =>    14,

    margin_bottom     =>  8.00,
    margin_left       =>  6.00,
    margin_top        =>  4.00,
    margin_right      =>  1.00,

    title_show        =>  1,
    title_size        =>  2.50,
    title_shift       =>  1.50,

    legend_show       =>     1,
    legend_text_size  =>  2.25,
    legend_orient     => 'horizontal',
    legend_box        => 'none',
    legend_inset      => -0.08,

    x_axis_shift      =>  4.00,
    x_axis_size       =>  2.25,
    x_axis_orient     => 'vertical',
    x_axis_p_just     => 'center',
    x_axis_h_just     => 'center',

    y_axis_shift      =>  1.25,
    y_axis_size       =>  2.25,
    y_axis_orient     => 'parallel',
    y_axis_p_just     => 'center',
    y_axis_h_just     => 'center',

    x_label_show      =>  0,
    x_label_size      =>  2.25,
    x_label_shift     =>  6.00,

    y_label_show      =>  1,
    y_label_size      =>  2.25,
    y_label_shift     =>  3.25,
  },

  presentation => {

    background_color  => 'white',
    image_width       =>   800,
    image_height      =>   600,
    font_size         =>    14,

    margin_bottom     =>  8.10,
    margin_left       =>  6.10,
    margin_top        =>  5.10,
    margin_right      =>  2.00,

    legend_show       =>  1,
    legend_text_size  =>  1.25,
    legend_orient     => 'horizontal',
    legend_box        => 'none',
    legend_inset      => -0.10,

    x_axis_shift      =>  0.00,
    x_axis_size       =>  1.25,
    x_axis_orient     => 'horizontal',
    #x_axis_orient     => 'vertical',
    x_axis_just       => 'center',

    y_axis_shift      =>  0.00,
    y_axis_size       =>  1.25,
    y_axis_orient     => 'parallel',
    y_axis_just       => 'center',

    x_label_show      =>  1,
    x_label_size      =>  1.50,
    x_label_shift     =>  6.00,

    y_label_show      =>  1,
    y_label_size      =>  1.50,
    y_label_shift     =>  3.50,

    title_show        =>  1,
    title_size        =>  1.75,
    title_shift       =>  3.00,

  },

);



################################################### AXIS ORIENTATION

my %LAS = ( 
  'parallel'      => 0, 
  'horizontal'    => 1, 
  'perpendicular' => 2, 
  'vertical'      => 3,
);

sub Translate_Axis_Orientation { 
  my $las = $_[0];
  if ( not $las =~ /^\d$/ ) { 
    if ( not defined ( $las = $LAS{$las} ) ) { 
      die "Unknown axis orientation '$las'.\n";
    }
  }
  return $las;
}


################################################# AXIS JUSTIFICATION

my %PADJ = ( 
  'left'    => 0.0, 
  'center'  => 0.5, 
  'right'   => 1.0,
);

sub Translate_Axis_Justification { 
  my $padj = $_[0];
  if ( not $padj =~ /^[\d\.-]+$/ ) { 
    if ( not defined ( $padj = $PADJ{$padj} ) ) { 
      die "Unknown axis justification '$padj'.\n";
    }
  }
  return $padj
}

################################################# LEGEND ORIENTATION

sub Translate_Legend_Orientation { 
  my $orient = $_[0];
  if ( $orient =~ /^hor/ ) { return 'TRUE'  }
  if ( $orient =~ /^ver/ ) { return 'FALSE' } 
  die "Unknown legend orientation '$orient'.\n";
}




##################################################### GENERATE PAIRS

sub Generate_Pairs {

  my $x_axes = $_[0];
  my $y_axes = $_[1];

  my $pair_i = 1;
  my @pairs = ();
  my %pairs = ();

  # Set up pair indecies
  foreach my $x ( @$x_axes ) { 
    foreach my $y ( @$y_axes ) { 
      $pairs{$x}{$y} = $pair_i++;
    }
  }

  # Intra X-Axis Comparisons
  foreach my $x ( @$x_axes ) { 
    foreach my $y_i ( 0 .. $#$y_axes ) { 
      foreach my $y_j ( $y_i+1 .. $#$y_axes ) { 
        push @pairs , [ $pairs{$x}{$y_axes->[$y_i]}, $pairs{$x}{$y_axes->[$y_j]} ];
      }
    }
  }

  # Intra X-Axis Comparisons
  foreach my $y ( @$y_axes ) { 
    foreach my $x_i ( 0 .. $#$x_axes ) { 
      foreach my $x_j ( $x_i+1 .. $#$x_axes ) { 
        push @pairs , [ $pairs{$x_axes->[$x_i]}{$y}, $pairs{$x_axes->[$x_j]}{$y} ];
      }
    }
  }

  if ( wantarray ) { return  @pairs } 
  else             { return \@pairs }

}


1;
