package Plot;
BEGIN { push @INC, "$ENV{CODE_BASE}/scouras"; }

#use 5.008006;
use strict;
use warnings;
#use Diagnostics;
use Utility;
use POSIX;
use Carp;
use Data::Dumper;
require Exporter;
use Math::Trig;


our @ISA = qw(Exporter);

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration	use RotLib ':all';
# If you do not need this, moving things directly into @EXPORT or @EXPORT_OK
# will save memory.
our %EXPORT_TAGS = ( 'all' => [ qw() ] );

our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

our @EXPORT = qw();

# CVS VERSION INFORMATION (AUTOMAGICALLY GENERATED BY CVS)
'$Revision: 1.0 $'              =~ /^.Revision: (.*) \$/; our $VERSION    = $1;
'$Date: 2009/08/24 22:41:12 $'  =~ /^.Date: (.*) \$/;     our $CHECKED_IN = $1;
'$Author: scouras $'            =~ /^.Author: (.*) \$/;   our $AUTHOR     = $1;



####################################################################
#                                       GETOPT::LONG QUICK REFERENCE
#-------------------------------------------------------------------
# Example Usages
#   my $foo = "";
#   my @bar = "";
#   GetOptions("foo" => \$foo, "bar" => \@bar);
#   my %options = ();
#   GetOptions(\%options, "foo=s, "bar", "help|?", "verbose|v+");
#
# Use anonymous function to parse arguments:
#   my $verbose = '';	# option variable with default value (false)
#   GetOptions ('verbose' => \$verbose,
#	              'quiet'   => sub { $verbose = 0 });
#
# Ignore @ARGS, use a custom array (for prefiltering)
#	  use Getopt::Long qw(GetOptionsFromArray);
#	  $ret = GetOptionsFromArray(\@myopts, ...);
#
# Enable single dash prefix to long names (i.e. '-verbose') 
#	  Getopt::Long::Configure ("bundling_override");
#
# Callback for processing orphan arguments (like filenames):
#   my $file;
#	  sub process { $file = $_[0] }
#	  GetOptions ( '<>' => \&process );
#
#-------------------------------------------------------------------
# Option Name Speicfiers
#   foo!        - allows negation with --nofoo/--no-foo
#   foo+        - incrementable option, as in -vvvv --verbose
#   foo=X       - required value of X. X can be:
#               - i: integer   f: float   s: string
#   foo:X       - optional value of X
#
#   foo=i       - When @foo, allows multiple options
#   foo=i@      - When $foo, creates ARRAY ref in foo
#               - Remember Utility::Parse_Range() to get full array.
#   rbg=i{3}    - Require 3 RGB value: --rgb 255 255 255
#   foo=i{X,Y}  - Mininum X, Maximum Y values
#   foo=i{X,}   - At least X values (no upper limit)
#
#   foo=i%      - Create HASH ref. Could also just use %foo
#               - Example: --define key=value
#
#   foo|bar     - Alias multiple options (stored as $foo{'foo'})
#
#-----------------------------------------------------------------------------
# Other Notes
#   case is ignored
#   args can be truncated to uniqueness --length or --l
#   return value can be ignored, as GetOptions calls die() 
#   GetOptions (''=>%stdio); to read STDIN
#   @ARGV will be emptied of all options. What remains should be
#     any unpassed arguments.
##############################################################################



##############################################################################
#                                                         COMMAND LINE OPTIONS
#-----------------------------------------------------------------------------
# Parses the command line and creates a configuration object. The options are
# stored in a matrix for me to edit, the converted to a hash, then converted
# to arguments for Getopt::Long.  The hash is also used to autogenerate the
# usage statement.
# The undef lines are so Usage knows where to put spaces for readability.
#-----------------------------------------------------------------------------
# TODO: Add generic axis parameters for when the parameters should apply to 
# both x and y axis (used for plot_matrix_categories).
##############################################################################


our @COMMAND_LINE_OPTIONS = (
  # OPTION         TYPE   DEFAULT             DESCRIPTION

  #--- X Axis Parameters
  [ 'xlabel',       's',  '"X Axis"',   'X-Axis Label'                        ],
  [ 'xmin',         'f',  'None',       'Min X-Axis Value or Index'           ],
  [ 'xmax',         'f',  'None',       'Max X-Axis Value or Index'           ],
  [ 'xticks',       's',  'Auto',       'Interval or Range of X-Ticks'        ],
  #[ 'xticksize',    'f',  'Auto',      'Size of X-Tick Marks'                ],
  [ 'xcat',         'b',  'Auto',       'Force X-Axis as Categories'          ],
  [ 'xaxis',        'b',  'Auto',       'Force X-Axis as Numerical Axis'      ],
  [ 'xlog',         'b',  'False',      'Force X-Axis on Logarithmic Scale'   ],
  [ 'xshift_axis',  'f',  '0.00',       'X-Axis Shift'                        ],
  [ 'xshift_label', 'f',  '6.00',       'X-Axis Label Shift'                  ],
  [ 'xscale_axis',  'f',  '1.25',       'X-Axis Tick Marks Scale',            ],
  [ 'xscale_label', 'f',  '1.50',       'X-Axis Label Scale',                 ],
  [ 'xlwd',         'f',  '4.0',        'X-Axis Line Width',                  ],
  [ 'xorient',      's',  'horiz',      'X-Axis Tick Mark Orientation',       ],
  [ 'xjustp',       's',  'center',     'X-Axis Tick Mark Justification Perp',],
  [ 'xjusth',       's',  'center',     'X-Axis Tick Mark Justification Horz',],
  undef,

  #--- Y Axis Parameters
  [ 'ylabel',       's',  '"Y Axis"',   'Y-Axis Label'                        ],
  [ 'ymin',         'f',  'None',       'Min Y-Axis Value or Index'           ],
  [ 'ymax',         'f',  'None',       'Max Y-Axis Value or Index'           ],
  [ 'yticks',       's',  'Auto',       'Interval or Range of Y-Ticks'        ],
  #[ 'yticksize',    'f',  'Auto',      'Size of Y-Tick Marks'                 ],
  [ 'ycat',         'b',  'Auto',       'Force Y-Axis as Categories'          ],
  [ 'yaxis',        'b',  'Auto',       'Force Y-Axis as Numerical Axis'      ],
  [ 'ylog',         'b',  'False',      'Force Y-Axis on Logarithmic Scale'   ],
  [ 'yshift_axis',  'f',  '0.00',       'Y-Axis Tick Marks Shift'             ],
  [ 'yscale_axis',  'f',  '1.25',       'Y-Axis Tick Marks Scale',            ],
  [ 'yshift_label', 'f',  '3.50',       'Y-Axis Label Shift'                  ],
  [ 'yscale_label', 'f',  '1.50',       'Y-Axis Label Scale',                 ],
  [ 'ylwd',         'f',  '4.0',        'Y-Axis Line Width',                  ],
  [ 'yorient',      's',  'parallel',   'Y-Axis Tick Mark Orientation',       ],
  [ 'yjustp',       's',  'center',     'Y-Axis Tick Mark Justification Perp',],
  [ 'yjusth',       's',  'center',     'Y-Axis Tick Mark Justification Horz',],
  undef,

  #--- Z Axis Parameters
  [ 'zlabel',       's',  '"Z Axis"',   'Z-Axis Label on Legend'              ],
  [ 'zmin',         'f',  'None',       'Min Z-Axis Value'                    ],
  [ 'zmax',         'f',  'None',       'Max Z-Axis Value'                    ],
  [ 'zlow',         'f',  'None',       'Min Colored Z-Axis Value'            ],
  [ 'zhigh',        'f',  'None',       'Max Colored Z-Axis Value'            ],
  [ 'zlowcolor',    'f',  'Gray',       'Color of Values Below Z-Low'         ],
  [ 'zhighcolor',   'f',  'Gray',       'Color of Values above Z-High'        ],
  [ 'zticks',       's',  'Auto',       'Interval or Range of Z-Ticks'        ],
  [ 'zsubticks',    's',  'Auto',       'Interval or Range of Minor Z-Ticks'  ],
  #[ 'zticksize',    'f',  'Auto',       'Size of Z-Tick Marks'                ],
  #[ 'zcat',         'b',  'Auto',       'Force Z-Axis as Categories'          ],
  [ 'zaxis',        'b',  'Auto',       'Force Z-Axis as Numerical Axis'      ],
  [ 'zlog',         'b',  'False',      'Force Z-Axis on Logarithmic Scale'   ],
  undef,

  #--- Title/Filename and Other Labels
  [ 'title',        's',  'Data File',  'Plot Title',                         ],
  [ 'title_scale',  'f',  '1.75',       'Title Font Scaling',                 ],
  [ 'title_shift',  'f',  '3.00',       'Title Shift',                        ],
  [ 'suffix',       's',  'None',       'Suffix for Title and Filename'       ],
  [ 'png',          's',  'Title',      'Output PNG Filename'                 ],
  
  [ 'writelog',     'b',  'False',      'Write log file'                      ],
  [ 'writeplt',     'b',  'False',      'Write R plot file'                   ],
  [ 'writepvl',     'b',  'False',      'Write p value file'                  ],
  [ 'writeavg',     'b',  'False',      'Write avg data file'                 ],
  [ 'writeraw',     'b',  'False',      'Write raw data file'                 ],

  [ 'min',          'f',  'None',       'Minimum threshold for data'          ],
  [ 'max',          'f',  'None',       'Maximum threshold for data'          ],

  [ 'annotation',   's',  'None',       'Annotations for Image'               ],
  [ 'points',       'b',  'False',      'Draw Individual Data Points'         ],
  [ 'pvalues',      'b',  'False',      'Calculate P-Values',                 ],
  [ 'stddev',       'b',  'False',      'Draw Standard Deviation Bars'        ],
  [ 'stderr',       'b',  'False',      'Draw Standard Error Bars'            ],
  [ 'quartiles',    'b',  'False',      'Draw Quartile Error Bars'            ],
  [ 'outline',      'b',  'False',      'Draw Outliers',                      ],
  [ 'whisker_range','f',  'All',        'Interquartile Scale for Whiskers',   ],

  [ 'verbose',      '+',  'False',      'Output Verbosity (Incrementable)',   ],
  [ 'datatype',     's',  'Auto',       'Specify Data File Format',           ], 

  undef,

  #--- Plot Dimensions
  [ 'help',         'b',  'False',      'Generate Basic Help Message',        ],
  [ 'style',        's',  'quick',      'Initial Plot Style',                 ],
  [ 'font_size',    'i',  '14',         'Base Font Size for all Text',        ],
  [ 'width',        'i',  '800',        'Plot Width in Pixels',               ],
  [ 'height',       'i',  '640',        'Plot Height in Pixels',              ],
  [ 'square',       'b',  'False',      'Force Square Aspect Ratio'           ],
  [ 'constrain',    'b',  'False',      'Limit Plot to Exact Matrix'          ],
  [ 'colorscheme',  's',  'grayscale',  'Color Scheme for Z-Axis'             ], 
  [ 'reverse',      'b',  'False',      'Reverse Color Scheme'                ],
  [ 'transpose',    'b',  'False',      'Transpose Data Matrix'               ],
  [ 'delimeter',    's',  '\s+',        'Column Separation Delimeter'         ],
  undef,

  #--- Legend
  [ 'nolegend',         'b', 'False',   'Do Not Draw Legend'                  ],
  [ 'legend_side',      's', 'top',     'Side of Plot for Legend'             ],
  [ 'legend',           'b', 'True',    'Show Legend (Negatable)'             ],
  [ 'legend_scale',     'f', '1.0',     'Legend Font Scaling',                ],
  [ 'legend_orient',    's', 'horiz',   'Legend Orientation (horiz or vert)', ],
  [ 'legend_inset',     'f', '-0.10',   'Legend Inset Spacing',               ],
  #[ 'legend_box',       'b', 'False',   'Draw Box Around Legend',             ], 

  #--- Other Plot Parameters
  [ 'background',       's', 'white',   'Background Color',                   ],
  [ 'margin_bottom',    'f', 'Auto',    'Bottom Margin'                       ],
  [ 'margin_top',       'f', 'Auto',    'Top Margin'                          ],
  [ 'margin_left',      'f', 'Auto',    'Left Margin'                         ],
  [ 'margin_right',     'f', 'Auto',    'Right Margin'                        ],
  [ 'line_type',        's', 'l',       'points, lines, both, over, steps, hist, none' ],
  undef,

);

our @OPTIONS_LIST = ( map { $_->[0] } grep { defined } @COMMAND_LINE_OPTIONS );

our %OPTION_GROUPS = ();
$OPTION_GROUPS{basic    } = [ qw(style title png height width colorscheme reverse verbose square ) ];
$OPTION_GROUPS{xaxis    } = [ qw(xlabel xmin xmax xlwd xticks xcat xaxis xlog xshift_axis xscale_axis 
                                 xshift_label xscale_label xorient xjustp xjusth) ];
$OPTION_GROUPS{yaxis    } = [ qw(ylabel ymin ymax ylwd yticks ycat yaxis ylog yshift_axis yscale_axis 
                                 yshift_label yscale_label yorient yjustp yjusth) ];
$OPTION_GROUPS{zaxis    } = [ qw(zlabel zmin zmax zlow zhigh zlowcolor zhighcolor 
                               zticks zsubticks zcat zaxis zlog) ];
$OPTION_GROUPS{axes     } = [ @{$OPTION_GROUPS{xaxis}},
                              @{$OPTION_GROUPS{yaxis}},  
                              @{$OPTION_GROUPS{zaxis}}, ];

$OPTION_GROUPS{legend   } = [ qw(legend legend_side legend_scale legend_orient legend_inset) ];
$OPTION_GROUPS{advanced } = [ qw(background suffix constrain transpose) ];

$OPTION_GROUPS{all      } = \@OPTIONS_LIST;
$OPTION_GROUPS{column   } = \@OPTIONS_LIST;
$OPTION_GROUPS{boxplot  } = \@OPTIONS_LIST;
$OPTION_GROUPS{lines    } = \@OPTIONS_LIST;


############################################################## OPTIONS TO HASH
# Optional filter to select options appropriate to a given plot type.


sub Options_to_Hash {
  my %options = ();
  foreach my $option ( @COMMAND_LINE_OPTIONS ) { 
    next if not defined $option;
    my ( $name, $type, $default, $desc ) = @$option;
    $options{$name} = {
      name    => $name,
      type    => $type,
      default => $default,
      desc    => $desc,
    };
  }
  

  if ( wantarray ) { return  %options }
  else             { return \%options }
}



######################################### PARSE COMMAND LINE WITH GETOPT::LONG
# TODO: Implement Filter for plot type.

use Getopt::Long qw(GetOptionsFromArray);

sub Get_Options { 

  my $CFG  = $_[0];
  my $args = $_[1];
  my $type = $_[2] || 'all';

  my @options = @{$OPTION_GROUPS{$type}};
  my %options = Options_to_Hash(\@COMMAND_LINE_OPTIONS, $type);

  #=============== First, create option flags to pass to Getopt::Long
  my @flags = ();

  foreach my $key ( @options ) { 
    my $opt = $options{$key};

    # Command line flag is the name with optional abreviation
    my $flag = $opt->{name} 
             . (defined $opt->{abv} ? "|$opt->{abv}" : "");
   
    # String, Integer, and Floats require a value 
    if ( $opt->{type} eq 's' 
      or $opt->{type} eq 'i'
      or $opt->{type} eq 'f' ) { 
        
        # Dilineate Mandatory or Optional 
        if ( $opt->{mandatory} ) { $flag .= "=" }
        else                     { $flag .= ":" }

        # Add Type
        $flag .= $opt->{type};
    }

    # Incrementable counts
    elsif ( $opt->{type} eq '+' ) { $flag .= "+" }

    # Negatable Booleans
    elsif ( $opt->{type} eq 'b' ) { $flag .= "!" }

    # Save to flag list
    #print "$key $flag\n";
    push @flags, $flag;
  }


  #=============== Now actually call it
  my $result = GetOptionsFromArray(
    $args,
    $CFG, 
    @flags,
  );

  if ( not $result ) { 
    confess "Get Options Failed";
  }


  #=============== Simplify some of the options
  # TODO: Maybe make functions out of these eventually.
  #

  if ( $CFG->{xaxis} ) { $CFG->{xaxis_type} = 'AXIS'      }
  if ( $CFG->{xcat } ) { $CFG->{xaxis_type} = 'CATEGORY'  }
  if ( $CFG->{yaxis} ) { $CFG->{yaxis_type} = 'AXIS'      }
  if ( $CFG->{xcat } ) { $CFG->{yaxis_type} = 'CATEGORY'  }


}



######################################################################## USAGE
sub Usage {
  my $message = $_[0] || '';
  my $type    = $_[1] || '';

  print "$0 <data file> <args>\n"
      . "$message\n"
      ;

  if ( not $type ) { exit 0 }

  my %options = Options_to_Hash();
  my @options = @{$OPTION_GROUPS{$type}};

  foreach my $option ( @options ) {  
    my $opt = $options{$option};
    printf "    --%-20s :  %3s  | %-40s (%s)\n",
           $opt->{name},
           $opt->{type},
           $opt->{desc},
           $opt->{default},
           ;


  }

  exit ($message ? 1 : 0);
}






####################################################################
#                                                    PLOT PARAMETERS
####################################################################

##################################### DEFAULT PLOT PARAMETER OPTIONS
# New styles copy an appropriate existing style, then change 
# specific parameters as required.

our %PLOT_STYLES = (
  default => { 
    default => {
      background        => 'white',
      width             =>   800,
      height            =>   600,
      font_size         =>    14,

      margin_bottom     =>  8.10,
      margin_left       =>  6.10,
      margin_top        =>  5.10,
      margin_right      =>  2.00,

      legend            =>  1,
      legend_scale      =>  1.25,
      legend_side       => 'top',
      legend_orient     => 'horizontal',
      legend_box        => 'none',
      legend_inset      => -0.10,

      xlabel            =>  'X-Axis',
      xshift_axis       =>  0.00,
      xscale_axis       =>  1.25,
      xshift_label      =>  6.00,
      xscale_label      =>  1.50,
      xorient           => 'horizontal',
      #x_axis_orient     => 'vertical',
      xjustp            => 'center',
      xjusth            => 'center',

      ylabel            =>  'Y-Axis',
      yshift_axis       =>  0.00,
      yscale_axis       =>  1.25,
      yshift_label      =>  3.50,
      yscale_label      =>  1.50,
      yorient           => 'parallel',
      yjustp            => 'center',
      yjusth            => 'center',

      title_show        =>  1,
      title_scale       =>  1.75,
      title_shift       =>  3.00,
    },
  },
);


#========================================================= REGISTER PLOT STYLE
# TODO: Error checking, merging with default, etc.

sub Register_Plot_Style { 
  my $type  = $_[0]; # Type of plot (column, matrix) style is for
  my $name  = $_[1]; # Name of the style
  my $style = $_[2]; # Style hash, as above

  if ( not defined $PLOT_STYLES{$type} ) { 
    $PLOT_STYLES{$type}{default} = $PLOT_STYLES{default}{default};
  }

  my %style = %{$PLOT_STYLES{$type}{default}};
  Utility::Set_Flags ( $style, \%style );
  $PLOT_STYLES{$type}{$name} = \%style;
}


#==== Quick Plot Style (the default)
Register_Plot_Style('column',  'default', $PLOT_STYLES{default}{default});
Register_Plot_Style('boxplot', 'default', $PLOT_STYLES{default}{default});
Register_Plot_Style('lines',   'default', $PLOT_STYLES{default}{default});





#---------------------------------------------------------------- XTAL COLUMNS
Register_Plot_Style('column', 'xtal_column', {
  width         =>      1000,
  height        =>       800,
  stddev        =>         1,
  stderr        =>         1,
  
  title_shift   =>        2.0,
  
  xlabel        =>         '',
  xorient       => 'vertical',
  xjusth        =>    'right',
  xshift_axis   =>        1.5,
  xscale_axis   =>        1.5,
  
  yshift_axis   =>        1.5,
  yscale_axis   =>        1.5,
  margin_bottom =>        9.0,
});
Register_Plot_Style('boxplot', 'xtal_boxplot', $PLOT_STYLES{boxplot}{xtal_column});


#--------------------------------------------------------------- XTAL BOXPLOTS
Register_Plot_Style('boxplot', 'xtal_boxplot', {
  width         =>       1000,
  height        =>        800,
  stddev        =>          1,
  stderr        =>          1,

  title_shift   =>          2.0,
  
  xlabel        =>         '',
  xorient       => 'vertical',
  xjusth        =>    'right',
  xshift_axis   =>          1.5,
  xscale_axis   =>          1.5,
  
  yshift_axis   =>          1.5,
  yscale_axis   =>          1.5,
  margin_bottom =>          9.0,
  outline       =>          0,
});
Register_Plot_Style('column', 'xtal_boxplot', $PLOT_STYLES{boxplot}{xtal_boxplot});








#==== Publication Quality 
#     Larger. 2x1 aspect ratio. 
#     Larger fonts and legend.
Register_Plot_Style( 'column', 'elements_publication', {
    image_width       =>  1000,
    image_height      =>   500,

    margin_bottom     =>  8.00,
    margin_left       =>  6.00,
    margin_top        =>  4.00,
    margin_right      =>  1.00,

    legend            =>     1,
    legend_text_size  =>  2.25,
    legend_orient     => 'horizontal',
    legend_box        => 'none',
    legend_inset      => -0.08,

    x_axis_shift      =>  4.00,
    x_axis_size       =>  2.25,
    x_axis_orient     => 'vertical',
    x_axis_p_just     => 'center',
    x_axis_h_just     => 'center',

    y_axis_shift      =>  1.25,
    y_axis_size       =>  2.25,
    y_axis_orient     => 'parallel',
    y_axis_p_just     => 'center',
    y_axis_h_just     => 'center',

    x_label_show      =>  0,
    x_label_size      =>  2.25,
    x_label_shift     =>  6.00,

    y_label_show      =>  1,
    y_label_size      =>  2.25,
    y_label_shift     =>  3.25,

    title_size        =>  2.50,
    title_shift       =>  1.50,
});
$PLOT_STYLES{column}{pub} = $PLOT_STYLES{column}{publication}; # Alias


#==== Presentation Quality 
#      Quick and dirty. 
Register_Plot_Style( 'column', 'elements_presentation', {
    background_color  => 'white',
    width             =>   800,
    height            =>   600,
    font_size         =>    14,

    margin_bottom     =>  8.10,
    margin_left       =>  6.10,
    margin_top        =>  5.10,
    margin_right      =>  2.00,

    legend            =>  1,
    legend_scale_font =>  1.25,
    legend_orient     => 'horizontal',
    legend_box        => 'none',
    legend_inset      => -0.10,

    xshift_axis       =>  0.00,
    xscale_axis       =>  1.25,
    xshift_label      =>  6.00,
    xscale_label      =>  1.50,
    xorient           => 'horizontal',
    xjustp            => 'center',
    xjusth            => 'center',

    yshift_axis       =>  0.00,
    yscale_axis       =>  1.25,
    yshift_label      =>  3.50,
    yscale_label      =>  1.50,
    yorient           => 'parallel',
    yjust             => 'center',

    title_show        =>  1,
    title_scale       =>  1.75,
    title_shift       =>  3.00,
});
$PLOT_STYLES{column}{pres} = $PLOT_STYLES{column}{presentation}; # Alias




##############################################################################
#                                                     AUTOMATIC CUSTOMIZATIONS
##############################################################################

sub Auto_Detect_Data_Type {
  my $CFG = $_[0];
  if ( $CFG->{FILES}{DATA} =~ /^properties/ ) { 
    $CFG->{datatype} = 'properties';
  } elsif ( $CFG->{FILES}{DATA} =~ /^histogram/ ) { 
    $CFG->{datatype} = 'histogram';
  } elsif ( $CFG->{FILES}{DATA} =~ /^statistics/ ) { 
    $CFG->{datatype} = 'statistics';
  } else { 
    confess "Auto_Detect_Data_Type !! Unknow datatype for file '$CFG->{FILES}{DATA}'.";
  }
}


##############################################################################
#                                     AUTO CUSTOMIZE PLOTS BASED ON FILE/TITLE
##############################################################################

sub Autocustomize_Plot {
  
  my $P    = $_[0];
  my $file = $_[1];



  my $X_LABEL_TEXT;
  my $Y_LABEL_TEXT;

  my $TYPE;
  my $FILE;

  if    ( $TYPE eq 'species'          ) { $X_LABEL_TEXT = 'Species' }
  elsif ( $TYPE eq 'all'              ) { $X_LABEL_TEXT = 'All Simulations' }
  elsif ( $TYPE eq 'mutant'           ) { $X_LABEL_TEXT = 'Mutation' }
  elsif ( $TYPE eq 'mutant_temp'      ) { $X_LABEL_TEXT = 'Mutation' }
  elsif ( $TYPE eq 'dc160'            ) { $X_LABEL_TEXT = 'Mutation' }
  elsif ( $TYPE eq 'e4'               ) { $X_LABEL_TEXT = 'Mutation' }
  elsif ( $TYPE eq 'mouse'            ) { $X_LABEL_TEXT = 'Mouse Mutant' }
  elsif ( $TYPE eq 'sheep'            ) { $X_LABEL_TEXT = 'Sheep Mutant' }
  elsif ( $TYPE eq 'xrmsd_mouse_mut'  ) { $X_LABEL_TEXT = 'Mutation' }
  elsif ( $TYPE eq 'xrmsd_mouse_elk_mut'  ) { $X_LABEL_TEXT = 'Mutation' }
  elsif ( $TYPE eq 'xrmsd_sheep_elk'  ) { $X_LABEL_TEXT = 'Species and Allele' }

  if    ( $FILE =~ /dssp/i  ) { $Y_LABEL_TEXT = "Residues (Count)" }
  elsif ( $FILE =~ /fdsa/i  ) { $Y_LABEL_TEXT = "Time in Contact (%)" }
  elsif ( $FILE =~ /sasa/i  ) { $Y_LABEL_TEXT = "Surface Area (Square Angstroms)" }
  elsif ( $FILE =~ /rmsd/i  ) { $Y_LABEL_TEXT = "RMSD (Angstroms)" }
  elsif ( $FILE =~ /mcgeo/i ) { $Y_LABEL_TEXT = "Atom Distance (Angstroms)" }
  elsif ( $FILE =~ /rmsft/i ) { $Y_LABEL_TEXT = "RMSF (Angstroms)" }
  elsif ( $FILE =~ /rmsf/i  ) { $Y_LABEL_TEXT = "RMSF (Angstroms)" }
  elsif ( $FILE =~ /vcont/i ) { $Y_LABEL_TEXT = "Contacts (Count)" }
  elsif ( $FILE =~ /cadist/i ){ $Y_LABEL_TEXT = "C$Utility::alpha Distance (Angstroms)" }





}



##############################################################################
#                                                               INITIALIZATION
##############################################################################
sub Initialize {

  my $type =   $_[0];
  my @args = @{$_[1]};

  if ( scalar @args == 0 ) { Usage() }

  #----- Generate initial configuration object using a style 
  my %CFG = ();
  my $style = 'default';
  Getopt::Long::Configure("pass_through");
  GetOptionsFromArray(\@args, 'style:s', \$style);
  if ( not exists $PLOT_STYLES{$type}{$style} ) { 
    confess "Plot::Initialize !! Unknown style $style. Options are quick, pres, or pub";
  }
  Utility::Set_Flags($PLOT_STYLES{$type}{$style}, \%CFG);
  
  #----- Parse command line options
  Getopt::Long::Configure("no_pass_through");
  Get_Options(\%CFG, \@args, $type);
  $CFG{type} = $type;

  #----- Output Help Message
  if ( $CFG{help} ) { Usage('', 'all') }


  #----- Any parameters remaining in @args are files
  my @files = @args;
  if ( scalar @files == 0 ) { 
    Usage("Plot::Initialize !! No data files passed");
  } elsif ( scalar @files > 1 ) { 
    Usage("Plot::Initialize !! More than one data file passed.");
  }
  Utility::Add_Path_to_Config(\%CFG, 'DATA', $files[0]);
  print "Using data file, '$files[0]'\n";

  if ( not -e $CFG{PATHS}{DATA} ) { 
    confess "Plot::Initialize !! Data file doesn't exist, '$CFG{PATHS}{DATA}'";
  }


  #----- Determine output PNG file
  my $png;
  if ( $CFG{png} ) { 
    $png = $CFG{png};
  } elsif ( $CFG{title} ) { 
    $png = $CFG{DIRS}{DATA} . "/" . lc (Utility::Clean_Filename($CFG{title}) . "\.png");
  } else { 
    $png = $CFG{PATHS}{DATA};
    $png =~ s/\.\w+$/\.png/;
  }
  my $base = $png;
  $base =~ s/\.png$//;

  Utility::Add_Path_to_Config(\%CFG, 'PNG',  $png);
  Utility::Add_Path_to_Config(\%CFG, 'BASE', $base);

  #print Dumper(\%CFG);
  #exit;
   
 
  #----- Determine Title and Base Filename
  #      Use user set title, then png file name, then data file name
  my $title;
  if    ( $CFG{title} ) { 
    $title = $CFG{title};
  } else {
    $title = join ' ', split /_+/, $CFG{FILES}{BASE};
  }
  $title =~ s/alpha/$Utility::alpha/g;
  $title =~ s/beta/$Utility::beta/g;
  $CFG{title} = $title;



  #----- Adjust Plot Parameters
  $CFG{xjusth       } = Plot::Translate_Axis_Justification($CFG{xjusth       });
  $CFG{xjustp       } = Plot::Translate_Axis_Justification($CFG{xjustp       });
  $CFG{yjusth       } = Plot::Translate_Axis_Justification($CFG{yjusth       });
  $CFG{yjustp       } = Plot::Translate_Axis_Justification($CFG{yjustp       });
  $CFG{xorient      } = Plot::Translate_Axis_Orientation  ($CFG{xorient      });
  $CFG{yorient      } = Plot::Translate_Axis_Orientation  ($CFG{yorient      });
  $CFG{legend_orient} = Plot::Translate_Legend_Orientation($CFG{legend_orient});

  $CFG{outline} |= 0;
  $CFG{whisker_range} |= 0;

  $CFG{verbose} |= 0;


  if ( wantarray ) { return  %CFG }
  else             { return \%CFG }

}



##############################################################################
#                                                                  IMPORT DATA
#-----------------------------------------------------------------------------
# The plotting programs generally want the input data broken down in various
# ways.  
#
# Reads file:
#   Extract raw numerical data
#   Extract row and column names
#   Determine row and column types
#   
#   For row and column headers:
#     Categories:
#       Create vector of quoted headers for R
#     Axis: 
#       Convert to floats
#       Add an extra column to the end that is one larger than the last column
#       Create vector of unquoted headers for R
#
##############################################################################

sub Import_Data {
  
  die "Don't use this yet, it doesn't return anything.";


  my $CFG  = $_[0] or confess "Need CFG";
  my $FILE = $_[1] or confess "Need filename";
 
  #=============== Read file data 
  my @CONTENTS = Utility::Read_Matrix($FILE, {transpose => $CFG->{transpose} || 0});
  $CONTENTS[0][0] =~ s/#\s*//; # Remove comment character
  my $data_width  = scalar @{$CONTENTS[1]} - 1;
  my $data_length = scalar @CONTENTS - 1;

  #=============== Extract potential X and Y headers
  my @x_headers = map { $_->[0] } @CONTENTS[1..$#CONTENTS];
  my @y_headers = @{$CONTENTS[0]};
  my $x_length   = scalar @x_headers;
  my $y_width    = scalar @y_headers;

  #--------------- Detect if there's a matrix title
  my $title      = '';
  if ( $y_width == ($data_width+1) ) { 
    $title = shift @y_headers;
  } elsif ( $y_width == $data_width ) { 
    # Do nothing, this is fine
  } else { 
    die "Disparity between data width and number of col headers";
  }

  #--------------- Verify x header for every row
  if ( $x_length != ($data_length-1) ) { 
    die "Disparity between data length and number of row headers.";
  }

  #=============== Detect/Verify Header Axis Types
  # Currently axes can only be of type category or vector
  # Categories are printed one at a time, evenly spaced.
  # Vectors are plotted at appropriate spacing along a continuous numerical axis
  # Axis can also be demarcated as data, in which case there were no headers in
  # the data file, and should simply be numbered 1..N.
  
  

  #=============== Extract the raw data
  my @data = ();
  foreach my $i ( 1..$#x_headers ) { 
    foreach my $j ( 1..$#y_headers ) { 
      my $datum = $CONTENTS[$i][$j];
      if ( not Utility::Is_Number($datum) ) { 
        die "Value at row $i col $j is not a number, '$datum'.";
      } 
      $data[$i-1][$j-1] = $datum;
    }
  }


}


##############################################################################
#                                                         DETERMINE AXIS TYPES
#-----------------------------------------------------------------------------
# There are three axis types:
#   Category  : text labels
#             : ticks centered under point
#   Axis      : a sequence of evenly spaced integers (I think?)
#             : ticks between points
#   Data      : possibly scatter plots?
#             : ticks between points?
#             : also means it's not labeled. Y-Axis in 2D, Z-axis in 3D.
#
# Parameters Generated:
#   z             : read.table('$TEMP_MATRIX')   # no longer used except for x,y
#   x             : x locations (default seq(0, length(z[,1]))
#   y             : y locations (default seq(0, length(z[1,]))
#   data          : as.matrix(array(  z, dimnames=NULL)) # main data source
#   R_ROW_LABELS  : row_labels and (x if axis_type = 'AXIS')
#   R_COL_LABELS  : col_labels and (y if axis_type = 'AXIS')
#
#
#   xtickloc      : if defined, xtick locations, else autogen with xaxt='i'
#   xticklab      : labels for xtickloc
#   xgrid         : 
#
#   tickloc/ticklab are dift from row_labels if R autogenerates them. may leave many out
#
#   tick_string   : CFG param that can overwrite these data
#   tick_interval : CFG param that can overwrite these data
#
# Now only a xticks/yticks parameter. Simply detect if it's a number or a 
# string (comma separated).
#
#-----------------------------------------------------------------------------
# Generation Algorithm
# --------------------
# 1)  Check command line parameters 
# 1a)   if tick_string is set, validate and use it
# 1b)   if tick_interval is set, use it 
#         categorical : indeces
#         axis/data   : integer steps
# 
# 2)  Categorical (label every category)
#
#
##############################################################################

sub Determine_Axis_Parameters { 
  my $CFG     = $_[0];
  my $axis    = $_[1];
  my $headers = $_[2] || [];

  my ( $axis_type, $ticks, $min, $max );
  my ( @tickloc, $tickloc, @ticklab, $ticklab, @axis_labels, $axis_labels ) ;
  if ( $axis eq 'x' ) { 
    $axis_type    = $CFG->{xaxis_type };
    $min          = $CFG->{xmin       };
    $max          = $CFG->{xmax       };
    $ticks        = $CFG->{xticks     };
  }
  if ( $axis eq 'y' ) { 
    $axis_type    = $CFG->{yaxis_type };
    $min          = $CFG->{ymin       };
    $max          = $CFG->{ymax       };
    $ticks        = $CFG->{yticks     };
  }

  #=============== Auto-determine and verify axis type
  my $categorical = scalar grep { not Utility::Is_Number($_) } @$headers;

  if ( not $axis_type ) { 
    if ( $categorical ) { $axis_type = 'CATEGORY' }
    else                { $axis_type = 'DATA'     }
  } else { 
    if ( $axis_type eq 'CATEGORY' ) { 
      # Actually don't need to text anything
    } else { 
      if ( $categorical ) { 
        #confess "Axis $axis set to $axis_type but has categorical data";
      }
    }
  }


  #=============== Generate Axis Labels

  if ( $axis_type eq 'AXIS' ) { 
    my $incr = 1;
    if ( scalar @$headers > 1 ) { $incr = $headers->[1] - $headers->[0] } 
    @axis_labels  = @$headers;
  } elsif ( $axis_type eq 'DATA' ) { 
    @axis_labels  = 1..($#$headers+2);
  } elsif ( $axis_type eq 'CATEGORY' ) { 
    @axis_labels = map { "'$_'" } @$headers;
    if ( not $ticks ) { $ticks = 1 }
  }  
  $axis_labels  = "c(" . (join ',', @axis_labels) . ")";


  #=============== Axis Tick Locations and Labels
  if ( $ticks ) { 
    #------------- Tick Locations
    if ( Utility::Is_Number($ticks) ) { 
      if ( not defined $min ) { $min = Utility::Min($headers) }
      if ( not defined $max ) { $max = Utility::Max($headers) }
      my $min_tick = POSIX::floor($min / $ticks) * $ticks;
      my $max_tick = POSIX::ceil ($max / $ticks) * $ticks;
      @tickloc = Utility::Range($min_tick, $max_tick, $ticks, 1);
    } else { 
      @tickloc = Utility::Parse_Range($ticks);
    }

    #------------- Tick Labels
    if ( $axis_type eq 'CATEGORY' ) { 
      @ticklab = @$headers[map{$_-1} @tickloc];
    } else { 
      @ticklab = @tickloc;
    }

    $tickloc = "c(" . (join ',', @tickloc) . ")";
    $ticklab = "c(" . (join ',', @ticklab) . ")";

  }


  if ( $axis eq 'x' ) { 
    $CFG->{xaxis_type     } = $axis_type;
    $CFG->{xaxis_labels   } = \@axis_labels;
    $CFG->{xaxis_labels_R } = $axis_labels;
    $CFG->{xtickloc       } = \@tickloc;
    $CFG->{xtickloc_R     } = $tickloc;
    $CFG->{xticklab       } = \@ticklab;
    $CFG->{xticklab_R     } = $ticklab;
    $CFG->{xgrid          } = \@tickloc;
    $CFG->{xgrid_R        } = $tickloc;
  }
  elsif ( $axis eq 'y' ) { 
    $CFG->{yaxis_type     } = $axis_type;
    $CFG->{yaxis_labels   } = \@axis_labels;
    $CFG->{yaxis_labels_R } = $axis_labels;
    $CFG->{ytickloc       } = \@tickloc;
    $CFG->{ytickloc_R     } = $tickloc;
    $CFG->{yticklab       } = \@ticklab;
    $CFG->{yticklab_R     } = $ticklab;
    $CFG->{ygrid          } = \@tickloc;
    $CFG->{ygrid_R        } = $tickloc;
  }
  

}



##############################################################################
#                                                DEOBFUSCATED PARAMETERS FOR R
##############################################################################


############################################################# AXIS ORIENTATION

my %LAS = ( 
  'parallel'      => 0, 
  'horizontal'    => 1, 
  'perpendicular' => 2, 
  'vertical'      => 3,
);

sub Translate_Axis_Orientation { 
  my $las = $_[0];
  if ( not $las =~ /^\d$/ ) { 
    if ( not defined ( $las = $LAS{$las} ) ) { 
      die "Unknown axis orientation '$las'.\n";
    }
  }
  return $las;
}


########################################################### AXIS JUSTIFICATION

my %PADJ = ( 
  'left'    => 0.0, 
  'center'  => 0.5, 
  'right'   => 1.0,
);

sub Translate_Axis_Justification { 
  my $padj = $_[0];
  if ( not defined $padj ) { 
    confess "Translate_Axis_Justification !! No parameter passed.";
  }
  if ( not $padj =~ /^[\d\.-]+$/ ) { 
    if ( not defined ( $padj = $PADJ{$padj} ) ) { 
      die "Unknown axis justification '$padj'.\n";
    }
  }
  return $padj
}

########################################################### LEGEND ORIENTATION

sub Translate_Legend_Orientation { 
  my $orient = $_[0];
  if ( $orient =~ /^hor/ ) { return 'TRUE'  }
  if ( $orient =~ /^ver/ ) { return 'FALSE' } 
  die "Unknown legend orientation '$orient'.\n";
}



##############################################################################
##############################################################################

############################################################### GENERATE PAIRS
# R Helper Function to convert a matrix to a list of every X,Y index in the 
# matrix, for use with a P-Value function in plot_columns

sub Generate_Pairs {

  my $x_axes = $_[0];
  my $y_axes = $_[1];

  my $pair_i = 1;
  my @pairs = ();
  my %pairs = ();

  # Set up pair indecies
  foreach my $x ( @$x_axes ) { 
    foreach my $y ( @$y_axes ) { 
      $pairs{$x}{$y} = $pair_i++;
    }
  }

  # Intra X-Axis Comparisons
  foreach my $x ( @$x_axes ) { 
    foreach my $y_i ( 0 .. $#$y_axes ) { 
      foreach my $y_j ( $y_i+1 .. $#$y_axes ) { 
        push @pairs , [ $pairs{$x}{$y_axes->[$y_i]}, $pairs{$x}{$y_axes->[$y_j]} ];
      }
    }
  }

  # Intra X-Axis Comparisons
  foreach my $y ( @$y_axes ) { 
    foreach my $x_i ( 0 .. $#$x_axes ) { 
      foreach my $x_j ( $x_i+1 .. $#$x_axes ) { 
        push @pairs , [ $pairs{$x_axes->[$x_i]}{$y}, $pairs{$x_axes->[$x_j]}{$y} ];
      }
    }
  }

  if ( wantarray ) { return  @pairs } 
  else             { return \@pairs }

}



##############################################################################
#                                                 COLOR BREAKS FOR IMAGE PLOTS
##############################################################################


sub R_Create_Breaks_Linear { 

  my $INCLUSIVE = 0.999;
  my $log_base = 10;

  my $OPT   = $_[0] or confess "No plotting options passed.\n";
  my $data  = $_[1] or confess "No plotting data passed.\n";

  $OPT->{'desired_tick_count'} = 10;


  my $cutoff_min            = $OPT->{cutoff_min     };
  my $cutoff_max            = $OPT->{cutoff_max     };
  my $user_colors_per_tick  = $OPT->{colors_per_tick};
  my $user_tick_size        = $OPT->{ztick_size     };

  if ( defined $user_colors_per_tick ) { 
    if ( $user_colors_per_tick == 0 ) { 
      confess "zcolors must be an integer >= 1";
    } elsif ( not Utility::Is_Integer($user_colors_per_tick) ) { 
      confess "zcolors must be an integer >= 1";
    }
  }
  
  
  #my @data_filtered = ( grep { $_ > 0 } map { @{$data->[$_]} } 0..$#$data );

  #my $data_min    = (defined $cutoff_min) ? $cutoff_min : (Utility::Min(\@data_filtered));
  #my $data_max    = (defined $cutoff_max) ? $cutoff_max : (Utility::Max(\@data_filtered));

  my $data_min    = Utility::Min($data);
  my $data_max    = Utility::Max($data);
  my $data_range  = $data_max - $data_min;

  if ( not defined $cutoff_min ) { $cutoff_min = $data_min }
  if ( not defined $cutoff_max ) { $cutoff_max = $data_max }
  my $cutoff_range = $cutoff_max - $cutoff_min;

  
  my $tick_size = $OPT->{ztick_size};
  my $colors_per_tick = $OPT->{colors_per_tick} || 1;
  my $tick_size_log = 0;
  my $tick_data_ratio = 0;
  if ( not defined $user_tick_size ) { 
    $tick_size_log = Utility::Get_Log_Under ( $log_base, $cutoff_range );
    $tick_size = $log_base ** $tick_size_log;
    
    $tick_data_ratio = $cutoff_range / $tick_size;
    if    ( $tick_data_ratio == 1 ) { $tick_size /=  5; $colors_per_tick = 4; }
    elsif ( $tick_data_ratio <= 2 ) { $tick_size /=  5; $colors_per_tick = 4; }
    elsif ( $tick_data_ratio <= 5 ) { $tick_size /=  2; $colors_per_tick = 5; } 
    else                            { $tick_size /=  1; $colors_per_tick = 1; }
  }
    
  if ( $user_colors_per_tick ) { $colors_per_tick = $user_colors_per_tick }
  if ( $user_tick_size       ) { $tick_size       = $user_tick_size       }


  #=============== Create Gradient Breaks
  my $gradient_min = POSIX::floor($cutoff_min/$tick_size)*$tick_size;
  my $gradient_max = POSIX::ceil ($cutoff_max/$tick_size)*$tick_size;
  if ( $OPT->{cutoff_min} ) { $gradient_min = $OPT->{cutoff_min} }
  if ( $OPT->{cutoff_max} ) { $gradient_max = $OPT->{cutoff_max} }
  my $gradient_range = $gradient_max - $gradient_min;

  my $num_ticks  = $gradient_range / $tick_size;
  my $num_colors = $num_ticks * $colors_per_tick;

  my $incr = $tick_size / $colors_per_tick;
  my $incr_log = Utility::Get_Log_Under ( $log_base, $cutoff_range );
  my $precision_incr = ($incr_log > 0) ? "%.4f" : ("%." . (-$incr_log+5) . "f");
  print "Range of $gradient_min to $gradient_max incr $incr\n";
  my @gradient_breaks = map { sprintf $precision_incr, $_ } 
                          Utility::Range($gradient_min, $gradient_max/$INCLUSIVE, $incr, 1);
            #= map { $_ * $tick_size / $colors_per_tick } 
            #                ($gradient_min/$tick_size*$colors_per_tick
            #               ..$gradient_max/$tick_size*$colors_per_tick);
  
  #=============== Legend Breaks
  my @legend_breaks = @gradient_breaks;
  my @legend_ticks  = Utility::Range($gradient_min, $gradient_max/$INCLUSIVE, $tick_size, 1);
  print "Range of $gradient_min to $gradient_max incr $tick_size\n";
                          # map { $_ * $tick_size } 
                          #( $gradient_min/$tick_size
                          #..$gradient_max/$tick_size);
  my $precision = ($tick_size_log > 0) ? "'%.0f'" : ("'%." . (-$tick_size_log+2) . "f'");
  my @legend_labels = map { sprintf $precision, $_  } @legend_ticks;
 
 
  #=============== Legend Title Position 
  my $title_x_pos   = 0.40;
  my $title_y_pos   = $legend_ticks[-1] + ($legend_ticks[-1]-$legend_ticks[0])*0.05;


  #=============== Make Inclusive, and Full Breaks
  $gradient_breaks[0] *= $INCLUSIVE;
  my @full_breaks = ( @gradient_breaks );
  $full_breaks[ 0] = $data_min;
  $full_breaks[-1] = $data_max;



  #=============== Breaks Configuration Object
  my %BREAKS = ( 
    gradient_breaks => \@gradient_breaks,
    #full_breaks     => \@gradient_breaks,
    full_breaks     => \@full_breaks,
    legend_breaks   => \@legend_breaks,
    legend_ticks    => \@legend_ticks,
    legend_labels   => \@legend_labels,
    num_colors      => $num_colors,
    legend_ext_min  => $gradient_min - 1 * $tick_size,
    legend_ext_max  => $gradient_max + 1 * $tick_size,
    title_x_pos     => $title_x_pos,
    title_y_pos     => $title_y_pos,
  );

  #=============== Output Info
  print "Data Min:    $data_min\n"
      . "Data Max:    $data_max\n"
      . "Cutoff Min:  $cutoff_min\n"
      . "Cutoff Max:  $cutoff_max\n"
      . "Grad Min:    $gradient_min\n"
      . "Grad Max:    $gradient_max\n"
      . "Tick Sz:     $tick_size\n"
      . "Tick Sz Lg:  $tick_size_log\n"
      . "Ticks/Data:  $tick_data_ratio\n"
      . "Crs/Tick:    $colors_per_tick\n"
      . "Increment:   $incr\n"
      . "Precision:   $precision\n"
      . "Gradient:        " . (join ',', @gradient_breaks) . "\n"
      . "Full:            " . (join ',', @full_breaks) . "\n"
      . "Legend Breaks:   " . (join ',', @legend_breaks) . "\n"
      . "Legend Ticks:    " . (join ',', @legend_ticks) . "\n"
      ;

  if ( wantarray ) { return  %BREAKS }
  else             { return \%BREAKS }


}

sub R_Create_Breaks_Log {

  my $INCLUSIVE = 0.999999999999999999;

  my $OPT   = $_[0] or confess "No plotting options passed.\n";
  my $data  = $_[1] or confess "No plotting data passed.\n";

  my $cutoff_min      = $OPT->{'cutoff_min'     };
  my $cutoff_max      = $OPT->{'cutoff_max'     };
  my $colors_per_tick = $OPT->{'colors_per_tick'} || 5;
  my $log_base        = $OPT->{'log_base'       };
  my $log_gradient    = $log_base**(1/$colors_per_tick);

  my @data_filtered = ( grep { $_ > 0 } map { @{$data->[$_]} } 0..$#$data );

  my $data_min = $cutoff_min || Utility::Min(\@data_filtered);
  my $data_max = $cutoff_max || Utility::Max(\@data_filtered);
  my ($data_min_log, $data_max_log) 
    = Utility::Get_Log_Range($log_base,
                             $data_min,
                             $data_max);

  ##### Determine the gradient range, either between cutoffs or for the whole data

  my $gradient_min_set = defined $OPT->{'gradient_min'};
  my $gradient_max_set = defined $OPT->{'gradient_max'};

  my $gradient_min = $OPT->{'gradient_min'} || $data_min;
  my $gradient_max = $OPT->{'gradient_max'} || $data_max;
  
  my ($gradient_min_log, $gradient_max_log) 
    = Utility::Get_Log_Range($log_base, 
                             $gradient_min,
                             $gradient_max);
  
  $gradient_min = $log_base ** $gradient_min_log;
  $gradient_max = $log_base ** $gradient_max_log;
  my $gradient_range_log = $gradient_max_log - $gradient_min_log;

  
  ##### Legend Labels
  my $legend_axis_min = $gradient_min / $log_base;
  my $legend_axis_max = $gradient_max;
  if ( $gradient_min_set ) { $legend_axis_min /= $log_base }
  if ( $gradient_max_set ) { $legend_axis_max *= $log_base }
  my $legend_ext_min  = $legend_axis_min / $log_base;
  my $legend_ext_max  = $legend_axis_max * $log_base;

  
  my $num_colors      = $gradient_range_log * $colors_per_tick;

  
  print "Data Min: $data_min\n"
      . "Data Max: $data_max\n"
      . "Grad Min: $gradient_min\n"
      . "Grad Max: $gradient_max\n"
      ;
  #exit;


  ##### Create base breaks over the gradient color range.
  my @gradient_breaks 
      = map { $gradient_min * pow( $log_gradient, $_ ) } 
            (0..$num_colors);
  # Ensure lower bound is inclusive. 
  $gradient_breaks[0] *= $INCLUSIVE; 

  ##### Full breaks
  my @full_breaks = @gradient_breaks;
  
  # Add on extra breaks for the colored cutoff ranges.
  if ( $gradient_min_set ) { unshift @full_breaks, $data_min*$INCLUSIVE; }
  if ( $gradient_max_set ) { push    @full_breaks, $data_max; }

  # Extend color range to 0 and "infinity"
  @full_breaks = ( 0, @full_breaks, $legend_ext_max );


  ##### Legend Breaks

  my @legend_breaks = ( $legend_axis_min, @gradient_breaks, $legend_axis_max );

  ###### Determine legend labels and their axis locations 
  my @legend_ticks
    = map { $gradient_min * pow ( $log_base, $_ ) }
          ( -1..$gradient_range_log );

  my @legend_labels
    = map { "expression($log_base^$_)" }
          ( $gradient_min_log..$gradient_max_log );

  # Add top and bottom cutoffs
  if ( $gradient_min_set ) { 
    unshift @legend_ticks,  $gradient_min_log * pow ( $log_base, -2 );
    unshift @legend_labels, "expression($log_base^$data_min_log)";
  }

  if ( $gradient_max_set ) { 
    unshift @legend_ticks,  $gradient_min_log * pow ( $log_base, $gradient_range_log+1 );
    unshift @legend_labels, "expression($log_base^$data_max_log)";
  }

  unshift @legend_labels, 0;

  my $title_x_pos   = 0.40;
  my $title_y_pos   = $legend_ticks[-1] + ($legend_ticks[-1]-$legend_ticks[0])*0.05;

  my %BREAKS = ( 
    gradient_breaks => \@gradient_breaks,
    full_breaks     => \@full_breaks,
    legend_breaks   => \@legend_breaks,
    legend_ticks    => \@legend_ticks,
    legend_labels   => \@legend_labels,
    num_colors      => $num_colors,
    legend_ext_min  => $legend_ext_min,
    legend_ext_max  => $legend_ext_max,
    title_x_pos     => $title_x_pos,
    title_y_pos     => $title_y_pos,
  );

  if ( wantarray ) { return  %BREAKS }
  else             { return \%BREAKS }


}





##############################################################################
#                                                           AXES AND GRIDLINES
##############################################################################

sub R_Axes_and_Gridlines { 

  my $CFG    = $_[0];
  my $axis   = $_[1];
  my $at     = $_[2];
  my $labels = $_[3];
  
  my $text = " #================= $axis-Axes and Grid Lines\n";
 
 
  my ($type, $num, $orient, $cex, $justp, $justh, $shift, $lwd, $abdir, $grid);
  if ( $axis eq 'X' or $axis eq 'x' ) { 
    $num      = 1;
    $type     = $CFG->{xaxis_type };
    $orient   = $CFG->{xorient    }; 
    $cex      = $CFG->{xscale_axis}; 
    $shift    = $CFG->{xshift_axis}; 
    $lwd      = $CFG->{xlwd       } || 4.0; 
    $justp    = $CFG->{xjustp     }; 
    $justh    = $CFG->{xjusth     }; 
    $abdir    = 'v';
    $grid     = 'nx'; 
  } else { 
    $num      = 2;
    $type     = $CFG->{yaxis_type };
    $orient   = $CFG->{yorient    }; 
    $cex      = $CFG->{yscale_axis}; 
    $lwd      = $CFG->{ylwd       } || 4.0; 
    $justp    = $CFG->{yjustp     }; 
    $justh    = $CFG->{yjusth     }; 
    $shift    = $CFG->{yshift_axis}; 
    $abdir    = 'h';
    $grid     = 'ny'; 
  }

  #--------------- Regularly Spaced Numeric Axis
  if ( $type eq 'AXIS' and $at) { 
    $text .= "
      axis ( $num, 
             at       = $at, 
             labels   = $labels, 
             las      = $orient, 
             cex.axis = $cex, 
             lwd      = $lwd, 
             padj     = $justp,
             hadj     = $justh,
             mpg      = c(4.0, $shift, 0), 
           )
      grid ( $grid    = $at, 
             col      = 'black', 
             lwd      = $lwd,
           )
      #abline ( $grid  = $at, 
      #         col    = 'black', 
      #         lwd    = $lwd, 
      #       )
  ";


  #--------------- Categorical Axis
  } elsif ( $type eq 'CATEGORY' ) { 
    $text . "
      axis ( $num, 
             at       = $at+0.5, 
             labels   = $labels, 
             las      = $orient, 
             cex.axis = $cex, 
             lwd      = $lwd,
             padj     = $justp,
             hadj     = $justh,
             mpg      = c(4.0, $shift, 0), 
           )
      grid ( $grid    = $at, 
             col      = 'black', 
             lwd      = $lwd,
           )
      #abline ( $grid  = $at, 
      #         col    = 'black', 
      #         lwd    = $lwd, 
      #       )
  ";

  #--------------- Irregularly Spaced Numeric Axis
  } else { 
    $text .= "
      axis ( $num, 
             at       = axTicks($num), 
             las      = $orient, 
             cex.axis = $cex, 
             lwd      = $lwd,
             padj     = $justp,
             hadj     = $justh,
             mpg      = c(4.0, $shift, 0), 
           )
      grid ( $grid    = NULL, 
             col      = 'black', 
             lwd      = $lwd,
           )
      #abline ( $grid  = axTicks( 1 ), 
      #         col    = 'black', 
      #         lwd    = 4 
      #       )
  ";
  }

}


##############################################################################
#                                                       TITLES AND AXIS LABELS
##############################################################################

sub R_Title_and_Labels { 

  my $type = $_[0];
  my $CFG  = $_[1];

  if ( $type eq 'title' ) { 
    if ( not $CFG->{title} ) { return "" }
    return "
      title ( main      = '$CFG->{title}',
              line      = $CFG->{title_shift},
              xpd       = NA,
              cex.main  = $CFG->{title_scale}, 
            )\n";
  }

  if ( $type eq 'x' ) { 
    if ( not $CFG->{xlabel} ) { return "" }
    return "
      title ( xlab      = '$CFG->{xlabel}',
              line      = $CFG->{xshift_label},
              xpd       = NA,
              cex.lab   = $CFG->{xscale_label}, 
            )\n";
  }

  if ( $type eq 'y' ) { 
    if ( not $CFG->{ylabel} ) { return "" }
    return "
      title ( ylab      = '$CFG->{ylabel}',
              line      = $CFG->{yshift_label},
              xpd       = NA,
              cex.lab   = $CFG->{yscale_label}, 
            )\n";
  }

  confess "Unknown title or axis type '$type'.\n";
}





##############################################################################
#                                                                 COLORSCHEMES
##############################################################################

sub R_Get_ColorRamp_Michelle { 
  return "myramp = colorRampPalette(c('darkred','darkorange3','gold','chartreuse4','cyan3','blue','darkorchid4','deeppink'), bias=1, space=c('rgb'), interpolate=c('linear'))" ;
}

sub R_Get_ColorRamp_Grayscale { 
  return "myramp = colorRampPalette(c('gray100', 'black'), bias=1, space=c('rgb'), interpolate=c('linear'))";
  #return "myramp = colorRampPalette(c('gray100', 'gray90', 'gray70', 'gray50', 'gray30', 'gray10', 'black'), bias=1, space=c('rgb'), interpolate=c('linear'))";
}

sub R_Get_ColorRamp_Rainbow_Cycle { 
  return "myramp = colorRampPalette(c('red4', 'red2', 'orange2', 'yellow2', 'green2', 'blue2', 'blue4', 'blueviolet', 'red4'), bias=1, space=c('rgb'), interpolate=c('linear'))";
}

sub R_Get_ColorRamp_Rainbow { 
  return "myramp = colorRampPalette(c('red4', 'red2', 'orange2', 'yellow2', 'green2', 'blue2', 'blue4'), bias=1, space=c('rgb'), interpolate=c('linear'))";
}

sub R_Get_ColorRamp_RedBlue {
  return "myramp = colorRampPalette(c("
    #. "'red4', "
    #. "'red2', "
    #. "'blue2', "
    #. "'blue4'  "
    . "'#90270F', " # red
    . "'#3D1E74', " # purple
    . "'#03207E'  " # blue
    . "), bias=1, space=c('Lab'), interpolate=c('spline'))";

}
sub R_Get_ColorRamp_WhiteBlue {
  return "myramp = colorRampPalette(c( 'white', 'blue4'), bias=1, space=c('Lab'), interpolate=c('linear'))";
}
sub R_Get_ColorRamp_WhiteRed {
  return "myramp = colorRampPalette(c( 'white', 'red4'), bias=1, space=c('Lab'), interpolate=c('linear'))";
}
sub R_Get_ColorRamp_RedWhiteBlue {
  return "myramp = colorRampPalette(c('red4', 'white', 'blue4'), bias=1, space=c('Lab'), interpolate=c('linear'))";
}
#sub R_Get_ColorRamp_RedWhiteWhiteBlue {
#  return "myramp = colorRampPalette(c('red4', 'red3', 'red2', 'white', 'white', 'blue2', 'blue3', 'blue4'), bias=1, space=c('rgb'), interpolate=c('linear'))";
#}

#----------------- Colors from Zach

sub R_Get_ColorRamp_Z1 { 
  return "myramp = colorRampPalette(c('#9A375F', '#D37A06', '#1F3E9B'), bias=1, space=c('rgb'), interpolate=c('linear'))";
}

sub R_Get_ColorRamp_Z2 { 
  return "myramp = colorRampPalette(c("
 
        . "'#1A0C70', " # dark blue
        #. "'#43327F', " # medium blue
        #. "'#4022A6', " # light blue

        . "'#712779', " # blue purple
        #. "'#90129E', " # red purple
        #. "'', " # dark purple

        . "'#9A081F', " # dark red
        #. "'#AF3649', " # medium red
        #. "'#E41738', " # light red

        . "'#A35409', " # red orange
        #. "'#F18219', " # yellow orange
        #. "'', " # orange

        . "'#F1BD19' " # dark yellow
        #. "'#FAD766' " # medium yellow
        #. "'#FAE5A3' " # light yellow
      
      
       
       
#       . "'#0A136B', " # blue 4
#       . "'#1A269E', " # blue 3
#       . "'#F6D958', " # yellow 3
#       . "'#F6E598', " # yellow 1
#       . "'#9C7F03', " # yellow 4
#       . "'#A22945', " # red 4
#       . "'#D20736', " # red 3
#       . "'#F0567A' " # red 2

       . "), bias=1.0, space=c('Lab'), interpolate=c('spline'))";
  #return "myramp = colorRampPalette(c('#0A136B', '#2B337A', '#A22945', '#F0567A', '#F6D958', '#F6E598'), bias=1, space=c('rgb'), interpolate=c('linear'))";
}

sub R_Get_ColorRamp_Z3 { 
  return "myramp = colorRampPalette(c('#9A375F', '#D37A06', '#1F3E9B'), bias=0.5, space=c('rgb'), interpolate=c('linear'))";
}


sub R_Get_Colors { 
  my $scheme        = $_[0];
  my $num_colors    = $_[1];
  my $reverse       = $_[2];
  my $z_scale       = $_[3];
  my $bottom_color  = $_[4];
  
  my $color_text;
  if    ( $scheme eq 'grayscale'      ) { $color_text = R_Get_ColorRamp_Grayscale()     }
  elsif ( $scheme eq 'z1'             ) { $color_text = R_Get_ColorRamp_Z1()            }
  elsif ( $scheme eq 'z2'             ) { $color_text = R_Get_ColorRamp_Z2()            }
  elsif ( $scheme eq 'z3'             ) { $color_text = R_Get_ColorRamp_Z3()            }
  elsif ( $scheme eq 'rb'             ) { $color_text = R_Get_ColorRamp_Rainbow()       }
  elsif ( $scheme eq 'rainbow'        ) { $color_text = R_Get_ColorRamp_Rainbow()       }
  elsif ( $scheme eq 'rbc'            ) { $color_text = R_Get_ColorRamp_Rainbow_Cycle() }
  elsif ( $scheme eq 'rainbow-cycle'  ) { $color_text = R_Get_ColorRamp_Rainbow_Cycle() }
  elsif ( $scheme eq 'michelle'       ) { $color_text = R_Get_ColorRamp_Michelle()      }
  elsif ( $scheme eq 'white-blue'     ) { $color_text = R_Get_ColorRamp_WhiteBlue()     } 
  elsif ( $scheme eq 'white-red'      ) { $color_text = R_Get_ColorRamp_WhiteRed()      } 
  elsif ( $scheme eq 'red-blue'       ) { $color_text = R_Get_ColorRamp_RedBlue()       } 
  elsif ( $scheme eq 'red-white-blue' ) { $color_text = R_Get_ColorRamp_RedWhiteBlue()  } 
#  elsif ( $scheme eq 'red-white-white-blue' ) { $color_text = R_Get_ColorRamp_RedWhiteWhiteBlue()  } 
  else { 
    confess "Unknown color scheme $scheme.  "
          . "Available options are grayscale, rainbow, michelle, red-blue, and red-white-blue.\n";
  }
  
  my $reverse_text = $reverse ? "base_colors = rev(base_colors)\n" : "";
  my $bottom_color_text = $bottom_color ? "'$bottom_color', " : "";

  my $text = "
##### COLOR SCHEME SETUP
$color_text
base_colors = myramp($num_colors)
$reverse_text
";

if ( $z_scale eq 'log' ) { 
  $text .= "
colors = c('white', $bottom_color_text base_colors)
long_colors = c(colors, base_colors[length(base_colors)])
";

} elsif ( $z_scale eq 'linear' ) { 
  $text .= "
colors = c($bottom_color_text base_colors);
long_colors = c(colors);
";
} else { 
  confess "Unknown z scale '$z_scale'";
}

  return $text;
}




##############################################################################
#                                                                      LEGENDS
##############################################################################

#-----------------------------------------------------------------------------
#                                                              STANDARD LEGEND
#-----------------------------------------------------------------------------

sub R_Legend_Standard { 

  my $CFG    = $_[0];
  my $labels = $_[1] || 'y_labels';
  my $colors = $_[2] || 'colors';

  #==== LEGEND
  return "
  #=============== LEGEND

  legend ( '$CFG->{legend_side}', 
           '$labels',
           xpd=NA, 
           cex=$CFG->{legend_scale}, 
           bty='n',   # No Box
           #bty='o',  # Complete box around legend
           horiz=$CFG->{legend_orient}, 
           inset=$CFG->{legend_inset},
           fill=$colors,
        )

";

}


#-----------------------------------------------------------------------------
#                                                 SPECTRUM BAR FOR IMAGE PLOTS
#-----------------------------------------------------------------------------

sub R_Legend_Spectrumbar { 

  my $OPT     = $_[0];
  my $BREAKS  = $_[1];

  my $log_axis_text = ($OPT->{'z_scale'} eq 'log') ? "log  = 'y',\n" : "";

  my $legend_mar = $OPT->{'legend_margins'} || [ 3.0, 0.0, 1.0, 1.0 ];
  my $legend_vscale = $OPT->{'legend_vscale'} || 1.0;
  $legend_mar->[0] /= $legend_vscale;
  $legend_mar->[2] /= $legend_vscale;
  
  my $lwd_minor = 1.5 * ($OPT->{'legend_lwd'} || 1.0);
  my $lwd_major = 3.0 * ($OPT->{'legend_lwd'} || 1.0);
  my $lwd_axis  = 2.0 * ($OPT->{'legend_lwd'} || 1.0);

  my $cex_title = 1.5 * ($OPT->{'legend_cex'} || 1.0);
  my $cex_axis  = 1.5 * ($OPT->{'legend_cex'} || 1.0);
  #my $cex_axis  = 1.5 * ($OPT->{'legend_cex'} || 1.0);

  my $text = "

# DRAW LEGEND IN RIGHT WINDOW

#mar <- mar.orig
#mar[1] <- $legend_mar->[0]
#mar[2] <- $legend_mar->[1]
#mar[3] <- $legend_mar->[2]
#mar[4] <- $legend_mar->[3]
#par(mar=mar, pty='m', lwd=$lwd_minor)

#mai = c(0.25, 0.0, 0.25, 0.5)
mai = c($legend_mar->[0], $legend_mar->[1], $legend_mar->[2], $legend_mar->[3])
par(mai=mai, pty='m', lwd=$lwd_minor)

plot.new()
plot.window( xlim = c(0,1),
             ylim = c( $BREAKS->{'legend_ext_min'}, $BREAKS->{'legend_ext_max'} ),
             xaxs = 'i',
             yaxs = 'i',
             $log_axis_text
             #log  = 'y',
)

legend_ticks    = c ( " . ( join ',', @{$BREAKS->{'legend_ticks' }} ) . " )
legend_labels   = c ( " . ( join ',', @{$BREAKS->{'legend_labels'}} ) . " )
legend_breaks   = c ( " . ( join ',', @{$BREAKS->{'legend_breaks'}} ) . " )

legend_x_start = 0.1
legend_x_stop  = 0.65

# Breaks are the steps between each color
# Possibly more than one per legend Z-Tick
rect( legend_x_start,
      legend_breaks[1:(length(legend_breaks)-1)],
      legend_x_stop,
      legend_breaks[2:(length(legend_breaks)-0)],
      col=colors,
      lwd=$lwd_minor,
    )

# Ticks are the steps between major Z-Ticks
rect( legend_x_start,
      legend_ticks[1:(length(legend_ticks)-1)],
      legend_x_stop,
      legend_ticks[2:(length(legend_ticks)-0)],
      lwd=$lwd_major
    )


axis( 4, 
      at=legend_ticks, 
      labels=legend_labels, 
      lwd=$lwd_axis,
      lty=1, 
      las=2, 
      mgp=c(0, 2, 0),
      line=-3, 
      tcl=-0.25,
      hadj=0.5,
      cex.axis=$cex_axis
    )
#title('$OPT->{'legend_label'}', cex.main=$cex_title, line=-2.5, outer=FALSE, adj=0.25)

text(#grconvertX(0.40, from='npc', to='user'), 
     #grconvertY(0.95, from='npc', to='user'), 
     $BREAKS->{'title_x_pos'},
     $BREAKS->{'title_y_pos'},
     cex=$cex_title, 
     labels='$OPT->{'legend_label'}')


#text($BREAKS->{'legend_ext_max'}, 0.5, labels='$OPT->{'legend_label'}')

"
;


  return $text;

}




##############################################################################
#                                                 PARSE SPECIALIZED DATA FILES
##############################################################################




sub Read_Specialty_File_Summary { 
  my $file = $_[0];
  my $type = $_[1];
  my $f_sp = $_[2];
  my $f_ph = $_[3];


    my @X_AXES;
    my @Y_AXES;
    my $FILE;
    my $FLIP;
    my $USE_MAX;
    my $USE_POINTS;
    my $MAX_Y;
    my $MIN_Y;



  print "Reading file $file\n";

  open IN, $file or die "Couldn't open file, '$file'. $!";
  my @header = map { s/#//g; uc } split /\s+/, scalar <IN>;
  my %header = map { $header[$_] => $_ } grep { not $header[$_]=~ /^\d+/ } 0..$#header;
  my @h_data = grep { $header[$_] =~ /^\d+$/ } 0..$#header;

  my %meta = ();
  my %data = ();
  my $line;
  while ( defined ( $line = <IN> ) ) { 
    next if $line =~ /^\s*$/;
    my @line = split /\s+/, $line;
    my %sim      = map { $_ => $line[$header{$_}] } keys %header;
    my @data     = @line[@h_data];
    
    #my ( $file, $species, $fragment, $mutant, $ph, $temp, $run, $mean, $sd, $min, $max, @data ) 
    #  = @line;
    die "Couldn't parse line $line" if not scalar @data;

    #print Dumper (\@data);
    #@data = @data[-10..-1];
    #print Dumper (\@data);

    my $matches_species = 0;
    my $matches_ph      = 0;
    if ( defined $f_sp and scalar @$f_sp > 0 ) { 
      foreach my $sp ( @$f_sp ) { $matches_species = 1 if $line =~ /\s$sp\s/i }
    } else { 
      $matches_species = 1;
    }
    
    if ( defined $f_ph and scalar @$f_ph > 0 ) { 
      foreach my $ph ( @$f_ph ) { $matches_ph      = 1 if $line =~ /\s$ph\s/i }
    } else {
      $matches_ph = 1;
    }
    if (not ($matches_species and $matches_ph)) { 
      #print "No match\n";
      next;
    }

    my ($title, $x_axis, $y_axis);
    #===== Type Species
    if ( $type eq 'species' ) { 
      next if $sim{'SPECIES'} =~ /mouses/i;
      next if ($sim{'MUTANT'} !~ /wt/i  and $sim{'SPECIES'} !~ /sheep/i);
      next if ($sim{'MUTANT'} !~ /arh/i and $sim{'SPECIES'} =~ /sheep/i);
      $title = "$sim{'SPECIES'}\_$sim{'PH'}";
      $x_axis = lc $sim{'SPECIES'};
      $y_axis = lc $sim{'PH'};

    #===== Type DC160
    } elsif ( $type eq 'dc160' ) { 
      next if not ($sim{'SPECIES'} =~ /dog/ or $sim{'SPECIES'} =~ /cat/);
      if ( $sim{'SPECIES'} eq 'dog' ) { 
        if ( $sim{'MUTANT'} eq 'wt' ) { 
          $x_axis = "Dog_D160";
        } elsif ( $sim{'MUTANT'} eq 'D162N' ) { 
          $x_axis = "Dog_N160";
        } else { 
          die "Unknown dog mutant $sim{'MUTANT'}\n";
        }
      } elsif ( $sim{'SPECIES'} eq 'cat' ) { 
        if ( $sim{'MUTANT'} eq 'wt' ) { 
          $x_axis = "Cat_N160";
        } elsif ( $sim{'MUTANT'} eq 'N162D' ) { 
          $x_axis = "Cat_D160";
        } else { 
          die "Unknown cat mutant $sim{'MUTANT'}\n";
        }
      } else { 
        die "Unexpected species $sim{'SPECIES'}\n";
      }
      $y_axis = $sim{'PH'};

    #===== All Simulations
    } elsif ( $type eq 'all' ) { 

      $x_axis = $sim{'FILE'};
      $y_axis = 1;

      $x_axis =~ s/\d+$//g;

    #===== Mutant Simulations
    } elsif ( $type eq 'mutant' ) { 

      $x_axis = $sim{'MUTANT'};
      $y_axis = $sim{'PH'};

    #===== Mutant Simulations
    } elsif ( $type eq 'mutant_temp' ) {

      $x_axis = $sim{'MUTANT'};
      $y_axis = "Temp " . $sim{'TEMP'} . "K";

    #===== Type E4
    } elsif ( $type eq 'e4' ) { 
      next if not ($sim{'SPECIES'} =~ /human/ or $sim{'SPECIES'} =~ /hamster/);
      if ( $sim{'SPECIES'} eq 'human' ) { 
        if ( $sim{'MUTANT'} eq 'wt' ) { 
          $x_axis = "Human_II";
        } elsif ( $sim{'MUTANT'} eq 'I138M_I139M' ) { 
          $x_axis = "Human_MM";
        } else { 
          die "Unknown human mutant $sim{'MUTANT'}\n";
        }
      } elsif ( $sim{'SPECIES'} eq 'hamster' ) { 
        if ( $sim{'MUTANT'} eq 'wt' ) { 
          $x_axis = "Hamster_MM";
        } elsif ( $sim{'MUTANT'} eq 'M138I_M139I' ) { 
          $x_axis = "Hamster_II";
        } else { 
          die "Unknown human mutant $sim{'MUTANT'}\n";
        }
      } else { 
        die "Unexpected species $sim{'SPECIES'}\n";
      }
      $y_axis = $sim{'PH'};

    #===== Type Sheep
    } elsif ( $type eq 'sheep' ) { 
      next if not ($sim{'SPECIES'} =~ /sheep/i or $sim{'SPECIES'} =~ /elk/i);
      $title = "$sim{'SPECIES'}\_$sim{'MUTANT'}\_$sim{'PH'}";
      if ( $sim{'SPECIES'} =~ /elk/i ) { $x_axis = uc $sim{'SPECIES'} } 
      else                             { $x_axis = uc $sim{'MUTANT'}  }
      $y_axis = lc $sim{'PH'};
      $x_axis =~ s/-/_/g;
      $x_axis =~ s/ARQ/SHEEP_ARQ/;
      $x_axis =~ s/ARH/SHEEP_ARH/;
      $x_axis =~ s/ARR/SHEEP_ARR/;


    #===== Type Mouse
    } elsif ( $type eq 'mouse' ) { 
      next if $sim{'FRAGMENT'} ne '108-231';
      next if not $sim{'SPECIES'} =~ /mouse/i;
      $title = "$sim{'SPECIES'}\_$sim{'MUTANT'}\_$sim{'PH'}";
      $x_axis = uc $sim{'MUTANT'};
      $y_axis = lc $sim{'PH'};
      $x_axis =~ s/-/_/g;

      $x_axis =~ s/218/219/g;
      $x_axis =~ s/221/222/g;
      $x_axis =~ s/212/213/g;
      $x_axis =~ s/169/170/g;
      $x_axis =~ s/173/174/g;
      $x_axis =~ s/226/227/g;
      $x_axis =~ s/225/226/g;
      $x_axis =~ s/167/168/g;
      $x_axis =~ s/217/218/g;
    }


    if    ( $y_axis =~ /neutral/i ) { $y_axis = 'pH.7' }
    elsif ( $y_axis =~ /ph5/i     ) { $y_axis = 'pH.5' }
    elsif ( $y_axis =~ /low/i     ) { $y_axis = 'pH.3' }

    if    ( $type eq 'species' ) { $x_axis = ucfirst $x_axis }
    elsif ( $type eq 'mouse'   ) { $x_axis = uc      $x_axis }
    elsif ( $type eq 'sheep'   ) { $x_axis = uc      $x_axis }

    push @X_AXES, $x_axis;
    push @Y_AXES, $y_axis;

    if ( $FLIP ) { 
      my $temp = $x_axis;
      $x_axis = $y_axis;
      $y_axis = $temp;
    }

    my $datum = $data{$x_axis}{$y_axis}[$sim{'RUN'}] = {};
    my $times = $datum->{'TIMES'} = \@data;
    foreach my $i ( 0..$#header ) { 
      if ( $header[$i] =~ /^\d+$/ ) {}# push @$times, $line[$i] }
      else                          { $datum->{uc $header[$i]} = $line[$i] }
    }


    ( $sim{'MEAN'}, $sim{'SD'} ) = Utility::Mean_and_Stddev ( @$times );
    $sim{'MAX'} = Utility::Max ( @$times );
    $sim{'MIN'} = Utility::Min ( @$times );
    $sim{'SE'}  = $sim{'SD'} / sqrt ( scalar @$times );
    
    $data{$x_axis}{$y_axis}[$sim{'RUN'}]{'MEAN'} = $sim{'MEAN'};
    $data{$x_axis}{$y_axis}[$sim{'RUN'}]{'SD'  } = $sim{'SD'  };
    $data{$x_axis}{$y_axis}[$sim{'RUN'}]{'SE'  } = $sim{'SE'  };
    $data{$x_axis}{$y_axis}[$sim{'RUN'}]{'MAX' } = $sim{'MAX' };
    $data{$x_axis}{$y_axis}[$sim{'RUN'}]{'MIN' } = $sim{'MIN' };

    if ( (not defined $meta{$x_axis}{$y_axis}{'MAX'})
      or ($sim{'MAX'} > $meta{$x_axis}{$y_axis}{'MAX'}) ) { 
      $meta{$x_axis}{$y_axis}{'MAX'} = $sim{'MAX'};
    };
    if ( (not defined $meta{$x_axis}{$y_axis}{'MIN'})
      or ($sim{'MIN'} < $meta{$x_axis}{$y_axis}{'MIN'}) ) { 
      $meta{$x_axis}{$y_axis}{'MIN'} = $sim{'MIN'};
    }

    push @{$meta{$x_axis}{$y_axis}{'MEANS'}}, $sim{'MEAN'};
    if ( $USE_POINTS ) { 
      if ( ($sim{'MEAN'}+$sim{'SD'}) > $MAX_Y ) { $MAX_Y = ($sim{'MEAN'}+$sim{'SD'})*1.05 }
    }
    if ( $USE_MAX ) { 
      if ( $sim{'MAX'} > $MAX_Y ) { $MAX_Y = $sim{'MAX'} * 1.05 }
    }

  }
  return \%data, \%meta, \@X_AXES, \@Y_AXES;
}



